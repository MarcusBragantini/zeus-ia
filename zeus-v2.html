<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zeus.IA - Plataforma de Trading Automatizada</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; 
            background: #000;
            color: #fff;
        }
        .min-h-screen { min-height: 100vh; }
        .bg-black { background: #000; }
        .bg-gray-800 { background: #1f2937; }
        .bg-gray-900 { background: #111827; }
        .bg-green-500 { background: #10b981; }
        .bg-green-600 { background: #059669; }
        .bg-green-700 { background: #047857; }
        .bg-green-900 { background: #064e3b; }
        .bg-red-600 { background: #dc2626; }
        .bg-red-700 { background: #b91c1c; }
        .bg-red-900 { background: #7f1d1d; }
        .bg-blue-600 { background: #2563eb; }
        .bg-blue-700 { background: #1d4ed8; }
        .bg-blue-900 { background: #1e3a8a; }
        .bg-yellow-600 { background: #d97706; }
        .bg-yellow-700 { background: #b45309; }
        .bg-yellow-900 { background: #78350f; }
        .text-white { color: #fff; }
        .text-black { color: #000; }
        .text-gray-300 { color: #d1d5db; }
        .text-gray-400 { color: #9ca3af; }
        .text-gray-500 { color: #6b7280; }
        .text-gray-700 { color: #374151; }
        .text-green-400 { color: #34d399; }
        .text-red-400 { color: #f87171; }
        .text-red-500 { color: #ef4444; }
        .text-green-500 { color: #10b981; }
        .text-yellow-400 { color: #fbbf24; }
        .text-yellow-500 { color: #f59e0b; }
        .text-orange-400 { color: #fb923c; }
        .text-blue-400 { color: #60a5fa; }
        .text-blue-500 { color: #3b82f6; }
        .flex { display: flex; }
        .flex-1 { flex: 1; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .justify-center { justify-content: center; }
        .space-x-2 > * + * { margin-left: 0.5rem; }
        .space-x-3 > * + * { margin-left: 0.75rem; }
        .space-x-4 > * + * { margin-left: 1rem; }
        .space-y-2 > * + * { margin-top: 0.5rem; }
        .space-y-6 > * + * { margin-top: 1.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-4 { padding: 1rem; }
        .p-6 { padding: 1.5rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
        .py-8 { padding-top: 2rem; padding-bottom: 2rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-3 { margin-bottom: 0.75rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mr-2 { margin-right: 0.5rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-3 { margin-top: 0.75rem; }
        .mt-4 { margin-top: 1rem; }
        .mx-4 { margin-left: 1rem; margin-right: 1rem; }
        .w-8 { width: 2rem; }
        .w-80 { width: 20rem; }
        .w-full { width: 100%; }
        .h-8 { height: 2rem; }
        .h-96 { height: 24rem; }
        .text-xs { font-size: 0.75rem; }
        .text-sm { font-size: 0.875rem; }
        .text-base { font-size: 1rem; }
        .text-lg { font-size: 1.125rem; }
        .text-xl { font-size: 1.25rem; }
        .text-2xl { font-size: 1.5rem; }
        .text-3xl { font-size: 1.875rem; }
        .font-bold { font-weight: bold; }
        .font-medium { font-weight: 500; }
        .rounded { border-radius: 0.25rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .border { border-width: 1px; }
        .border-b { border-bottom-width: 1px; }
        .border-t { border-top-width: 1px; }
        .border-gray-600 { border-color: #4b5563; }
        .border-gray-700 { border-color: #374151; }
        .border-gray-800 { border-color: #1f2937; }
        .border-green-600 { border-color: #059669; }
        .border-red-600 { border-color: #dc2626; }
        .border-blue-600 { border-color: #2563eb; }
        .border-yellow-600 { border-color: #d97706; }
        .block { display: block; }
        .inline-block { display: inline-block; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .hover\:bg-green-700:hover { background: #047857; }
        .hover\:bg-red-700:hover { background: #b91c1c; }
        .hover\:bg-red-900:hover { background: #7f1d1d; }
        .hover\:bg-blue-700:hover { background: #1d4ed8; }
        .hover\:bg-yellow-700:hover { background: #b45309; }
        .hover\:bg-gray-800:hover { background: #1f2937; }
        .hover\:text-red-300:hover { color: #fca5a5; }
        .transition-colors { transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out; }
        .disabled\:bg-gray-600:disabled { background: #4b5563; }
        .disabled\:cursor-not-allowed:disabled { cursor: not-allowed; }
        .underline { text-decoration: underline; }
        .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .overflow-x-auto { overflow-x: auto; }
        .min-w-0 { min-width: 0; }
        .flex-wrap { flex-wrap: wrap; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .grid { display: grid; }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .whitespace-nowrap { white-space: nowrap; }
        .break-all { word-break: break-all; }
        .pt-3 { padding-top: 0.75rem; }
        
        /* Anima√ß√µes */
        .animate-spin {
          animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        button { border: none; cursor: pointer; }
        input, select { 
          border: 1px solid #374151; 
          outline: none; 
          background: #1f2937 !important; 
          color: #ffffff !important; 
        }
        input:focus, select:focus { 
          border-color: #10b981; 
          background: #1f2937 !important; 
          color: #ffffff !important; 
        }
        select { 
          color: #ffffff !important; 
          background: #1f2937 !important; 
        }
        select option { 
          background: #1f2937 !important; 
          color: #ffffff !important; 
        }
        input::placeholder { 
          color: #9ca3af !important; 
        }
        .loading { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            background: #000; 
            color: #fff; 
        }
        canvas {
            max-height: 300px !important;
        }
        .error-message {
            background: #7f1d1d;
            border: 1px solid #dc2626;
            color: #f87171;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        /* Responsividade */
        @media (max-width: 768px) {
            .flex-mobile-col { flex-direction: column; }
            .w-80 { width: 100%; }
            .space-x-2 > * + * { margin-left: 0.25rem; }
            .space-x-3 > * + * { margin-left: 0.5rem; }
            .space-x-4 > * + * { margin-left: 0.5rem; }
            .p-4 { padding: 0.75rem; }
            .px-4 { padding-left: 0.75rem; padding-right: 0.75rem; }
            .text-xl { font-size: 1rem; }
            .text-2xl { font-size: 1.25rem; }
            .text-3xl { font-size: 1.5rem; }
            .h-96 { height: 200px; }
            .py-8 { padding-top: 1rem; padding-bottom: 1rem; }
            .mobile-hidden { display: none; }
            .mobile-text-xs { font-size: 0.625rem; }
            .mobile-px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
            .mobile-py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
            .mobile-mb-4 { margin-bottom: 1rem; }
            .mobile-space-y-4 > * + * { margin-top: 1rem; }
        }
        
        @media (max-width: 480px) {
            .text-lg { font-size: 1rem; }
            .text-xl { font-size: 0.875rem; }
            .px-6 { padding-left: 0.5rem; padding-right: 0.5rem; }
            .py-3 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
            .space-x-2 > * + * { margin-left: 0.125rem; }
            .h-96 { height: 180px; }
            canvas { max-height: 180px !important; }
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">
            <div>Carregando Zeus.IA...</div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Componente de gr√°fico simples com Chart.js
        const SimpleChart = ({ data, symbol }) => {
          const canvasRef = useRef(null);
          const chartRef = useRef(null);

          useEffect(() => {
            try {
              if (!canvasRef.current || !data.length) return;

              const ctx = canvasRef.current.getContext('2d');
              
              if (chartRef.current) {
                chartRef.current.destroy();
              }

              chartRef.current = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: data.map(d => d.time),
                  datasets: [{
                    label: 'Pre√ßo',
                    data: data.map(d => d.price),
                    borderColor: '#10B981',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    tension: 0.1,
                    pointRadius: 0
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  interaction: {
                    intersect: false,
                    mode: 'index'
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: {
                      enabled: window.innerWidth > 768
                    }
                  },
                  scales: {
                    x: {
                      grid: { color: '#374151' },
                      ticks: { 
                        color: '#6B7280', 
                        maxTicksLimit: window.innerWidth > 768 ? 10 : 5,
                        font: {
                          size: window.innerWidth > 768 ? 12 : 10
                        }
                      }
                    },
                    y: {
                      grid: { color: '#374151' },
                      ticks: {
                        color: '#6B7280',
                        font: {
                          size: window.innerWidth > 768 ? 12 : 10
                        },
                        callback: function(value) {
                          return value.toFixed(symbol && symbol.includes('R_') ? 3 : 5);
                        }
                      }
                    }
                  }
                }
              });

              const handleResize = () => {
                if (chartRef.current) {
                  chartRef.current.resize();
                }
              };

              window.addEventListener('resize', handleResize);

              return () => {
                window.removeEventListener('resize', handleResize);
                if (chartRef.current) {
                  chartRef.current.destroy();
                }
              };
            } catch (error) {
              console.error('Erro no gr√°fico:', error);
            }
          }, [data, symbol]);

          return React.createElement('canvas', {
            ref: canvasRef,
            style: { width: '100%', height: '300px' }
          });
        };

        function DerivTradingPlatform() {
          const [balance, setBalance] = useState(0);
          const [currentPrice, setCurrentPrice] = useState(0);
          const [isTrading, setIsTrading] = useState(false);
          const [isConnected, setIsConnected] = useState(false);
          const [lineData, setLineData] = useState([]);
          const [entryValue, setEntryValue] = useState('10');
          const [duration, setDuration] = useState('5');
          const [contractType, setContractType] = useState('CALL');
          const [strategy, setStrategy] = useState('Agressivo');
          // Claude IA √© fixo
          const aiModel = 'Claude IA';
          const [symbol, setSymbol] = useState('R_50');
          
          // Configura√ß√µes do Bot Aut√¥nomo
          const [maxProfit, setMaxProfit] = useState('100');
          const [maxLoss, setMaxLoss] = useState('50');
          const [isAutonomousMode, setIsAutonomousMode] = useState(false);
          const [marketAnalysis, setMarketAnalysis] = useState(null);
          const [selectedCurrency, setSelectedCurrency] = useState('R_50');
          const [analysisHistory, setAnalysisHistory] = useState([]);
          
          // An√°lise de m√∫ltiplas moedas
          const [allMarketAnalysis, setAllMarketAnalysis] = useState({});
          const [bestAsset, setBestAsset] = useState(null);
          const [isAnalyzingAllAssets, setIsAnalyzingAllAssets] = useState(false);
          const [trades, setTrades] = useState([]);
          const [profit, setProfit] = useState(0.00);
          const [apiToken, setApiToken] = useState('');
          const [connectionStatus, setConnectionStatus] = useState('Desconectado');
          const [errorMessage, setErrorMessage] = useState('');
          const [isExecutingTrade, setIsExecutingTrade] = useState(false);
          const [isLoadingContracts, setIsLoadingContracts] = useState(false);
          const wsRef = useRef(null);
          const [accountInfo, setAccountInfo] = useState(null);

          const derivSymbols = {
            'R_50': 'Volatility 50 Index',
            'R_75': 'Volatility 75 Index',
            'R_100': 'Volatility 100 Index',
            'BOOM500': 'Boom 500 Index',
            'BOOM1000': 'Boom 1000 Index',
            'CRASH500': 'Crash 500 Index',
            'CRASH1000': 'Crash 1000 Index',
            'EURUSD': 'EUR/USD',
            'GBPUSD': 'GBP/USD',
            'USDJPY': 'USD/JPY'
          };

          // Moedas priorit√°rias (mais est√°veis para trading)
          const prioritySymbols = ['R_50', 'R_75', 'R_100', 'EURUSD', 'GBPUSD'];
          
          // Estado para controlar tentativas de fallback
          const [fallbackAttempts, setFallbackAttempts] = useState(0);
          const [unavailableSymbols, setUnavailableSymbols] = useState(new Set());
          
          // Estados para moedas ativas da corretora
          const [activeSymbols, setActiveSymbols] = useState([]);
          const [symbolDurations, setSymbolDurations] = useState({});
          const [isCheckingSymbols, setIsCheckingSymbols] = useState(false);
          const [lastSymbolCheck, setLastSymbolCheck] = useState(null);
          
          // Estados para integra√ß√£o com Claude IA
          const [claudeApiKey, setClaudeApiKey] = useState('');
          const [isUsingRealAI, setIsUsingRealAI] = useState(false);
          const [aiAnalysisResult, setAiAnalysisResult] = useState(null);
          const [showClaudeSetup, setShowClaudeSetup] = useState(true);
          const [claudeConfigured, setClaudeConfigured] = useState(false);

          const clearError = () => {
            setErrorMessage('');
          };

          // Configurar Claude IA
          const configureClaude = () => {
            if (claudeApiKey && claudeApiKey.trim().length > 0) {
              setClaudeConfigured(true);
              setIsUsingRealAI(true);
              setShowClaudeSetup(false);
              console.log('‚úÖ Claude IA configurado com sucesso!');
              showSuccess('Claude IA configurado com sucesso!');
            } else {
              showError('Por favor, insira um token v√°lido do Claude IA');
            }
          };

          // Pular configura√ß√£o do Claude (usar an√°lise local como fallback)
          const skipClaudeSetup = () => {
            setClaudeConfigured(true);
            setIsUsingRealAI(false);
            setShowClaudeSetup(false);
            console.log('‚ö†Ô∏è Claude IA n√£o configurado, usando an√°lise local como fallback');
            showSuccess('Usando an√°lise local como fallback');
          };

          // Fun√ß√£o utilit√°ria para formata√ß√£o segura de n√∫meros
          const safeFormatNumber = (value, decimals = 2, fallback = '0.00') => {
            try {
              if (isNaN(value) || !isFinite(value)) {
                return fallback;
              }
              return value.toFixed(decimals);
            } catch (error) {
              console.warn('Erro ao formatar n√∫mero:', value, error);
              return fallback;
            }
          };

          // Fun√ß√£o utilit√°ria para c√°lculos seguros
          const safeCalculate = (operation, fallback = 0) => {
            try {
              const result = operation();
              if (isNaN(result) || !isFinite(result)) {
                return fallback;
              }
              return result;
            } catch (error) {
              console.warn('Erro no c√°lculo:', error);
              return fallback;
            }
          };

          // An√°lise local avan√ßada (funciona sem APIs externas)
          const analyzeWithLocalAI = (marketData, aiModel) => {
            try {
              console.log(`ü§ñ An√°lise h√≠brida ${aiModel} (algoritmo avan√ßado)...`);
              
              const { symbol, prices, trend, momentum, volatility, avgPrice, priceChange } = marketData;
              
              // An√°lise t√©cnica avan√ßada
              const rsi = calculateRSI(prices);
              const macd = calculateMACD(prices);
              const bollinger = calculateBollingerBands(prices);
              const supportResistance = calculateSupportResistance(prices);
              
              // An√°lise de padr√µes
              const patterns = analyzePatterns(prices);
              
              // An√°lise de volume (simulado)
              const volumeAnalysis = analyzeVolume(prices);
              
              // An√°lise de sentiment
              const sentiment = analyzeSentiment(trend, momentum, volatility, rsi);
              
              // Decis√£o baseada em m√∫ltiplos indicadores
              let shouldTrade = false;
              let confidence = 0;
              let recommendedType = 'CALL';
              let riskLevel = 'm√©dio';
              let reason = '';
              
              // L√≥gica de decis√£o sofisticada (simulando Claude IA)
              const indicators = {
                trend: trend === 'UP' ? 1 : trend === 'DOWN' ? -1 : 0,
                momentum: momentum > 0.005 ? 1 : momentum < -0.005 ? -1 : 0,
                volatility: volatility > 0.01 ? 1 : 0,
                rsi: rsi > 70 ? -1 : rsi < 30 ? 1 : 0,
                macd: macd > 0 ? 1 : -1,
                patterns: patterns.bullish ? 1 : patterns.bearish ? -1 : 0,
                sentiment: sentiment > 0.6 ? 1 : sentiment < 0.4 ? -1 : 0
              };
              
              // An√°lise adicional para simular Claude IA
              const marketConditions = {
                isTrending: Math.abs(momentum) > 0.01,
                isVolatile: volatility > 0.015,
                isOversold: rsi < 30,
                isOverbought: rsi > 70,
                hasStrongSignal: Math.abs(macd) > 0.001,
                isConsistent: Math.abs(shortMomentum - longMomentum) < 0.01
              };
              
              const totalScore = Object.values(indicators).reduce((sum, score) => sum + score, 0);
              
              // Ajustar score baseado nas condi√ß√µes de mercado
              let adjustedScore = totalScore;
              if (marketConditions.isTrending && marketConditions.isVolatile) adjustedScore += 1;
              if (marketConditions.isOversold && trend === 'UP') adjustedScore += 1;
              if (marketConditions.isOverbought && trend === 'DOWN') adjustedScore += 1;
              if (marketConditions.hasStrongSignal) adjustedScore += 0.5;
              if (marketConditions.isConsistent) adjustedScore += 0.5;
              
              // Decis√£o baseada no score ajustado (simulando Claude IA) - THRESHOLDS AJUSTADOS
              console.log(`üîç ${symbol}: Score base=${totalScore}, Score ajustado=${adjustedScore.toFixed(1)}, Tend√™ncia=${trend}, Momentum=${(momentum * 100).toFixed(2)}%`);
              
              if (adjustedScore >= 1) { // Reduzido de 3 para 1
                shouldTrade = true;
                recommendedType = 'CALL';
                confidence = Math.min(0.95, 0.4 + (adjustedScore * 0.12)); // Aumentado multiplicador
                riskLevel = adjustedScore >= 3 ? 'baixo' : 'm√©dio'; // Reduzido threshold
                reason = `An√°lise Claude IA: Sinal de alta detectado. Tend√™ncia ${trend}, momentum ${(momentum * 100).toFixed(2)}%, RSI ${rsi.toFixed(1)}, volatilidade ${(volatility * 100).toFixed(2)}%. Padr√µes ${patterns.bullish ? 'altistas' : 'neutros'}. Score: ${adjustedScore.toFixed(1)}`;
              } else if (adjustedScore <= -1) { // Reduzido de -3 para -1
                shouldTrade = true;
                recommendedType = 'PUT';
                confidence = Math.min(0.95, 0.4 + (Math.abs(adjustedScore) * 0.12)); // Aumentado multiplicador
                riskLevel = adjustedScore <= -3 ? 'baixo' : 'm√©dio'; // Reduzido threshold
                reason = `An√°lise Claude IA: Sinal de baixa detectado. Tend√™ncia ${trend}, momentum ${(momentum * 100).toFixed(2)}%, RSI ${rsi.toFixed(1)}, volatilidade ${(volatility * 100).toFixed(2)}%. Padr√µes ${patterns.bearish ? 'baixistas' : 'neutros'}. Score: ${adjustedScore.toFixed(1)}`;
              } else {
                shouldTrade = false;
                confidence = Math.max(0.1, 0.2 + (Math.abs(adjustedScore) * 0.05)); // Confian√ßa m√≠nima maior
                reason = `An√°lise Claude IA: Sinal neutro. Score ${adjustedScore.toFixed(1)}, condi√ß√µes n√£o favor√°veis para trading. Tend√™ncia ${trend}, momentum ${(momentum * 100).toFixed(2)}%, RSI ${rsi.toFixed(1)}`;
                riskLevel = 'alto';
              }
              
              // Ajustar baseado na estrat√©gia
              switch (strategy) {
                case 'Conservador':
                  confidence *= 0.8;
                  if (riskLevel === 'alto') shouldTrade = false;
                  break;
                case 'Moderado':
                  confidence *= 0.9;
                  break;
                case 'Agressivo':
                  confidence *= 1.0;
                  break;
              }
              
              return {
                shouldTrade: shouldTrade && confidence > 0.3, // Reduzido de 0.6 para 0.3
                confidence: Math.max(0, Math.min(1, confidence)),
                reason: reason,
                recommendedType: recommendedType,
                riskLevel: riskLevel,
                indicators: indicators,
                marketConditions: marketConditions,
                totalScore: totalScore,
                adjustedScore: adjustedScore,
                aiModel: `${aiModel} (H√≠brido)`
              };
              
            } catch (error) {
              console.error('Erro na an√°lise local:', error);
              return {
                shouldTrade: false,
                confidence: 0,
                reason: 'Erro na an√°lise local',
                recommendedType: 'CALL',
                riskLevel: 'alto',
                aiModel: `${aiModel} (Local)`
              };
            }
          };

          // Fun√ß√µes auxiliares para an√°lise t√©cnica
          const calculateRSI = (prices) => {
            if (prices.length < 14) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = 1; i < 14; i++) {
              const change = prices[i] - prices[i - 1];
              if (change > 0) gains += change;
              else losses -= change;
            }
            
            const avgGain = gains / 13;
            const avgLoss = losses / 13;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
          };

          const calculateMACD = (prices) => {
            if (prices.length < 26) return 0;
            
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            
            return ema12 - ema26;
          };

          const calculateEMA = (prices, period) => {
            if (prices.length < period) return prices[prices.length - 1];
            
            const multiplier = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 1; i < prices.length; i++) {
              ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
            }
            
            return ema;
          };

          const calculateBollingerBands = (prices) => {
            if (prices.length < 20) return { upper: 0, middle: 0, lower: 0 };
            
            const sma = prices.slice(-20).reduce((sum, price) => sum + price, 0) / 20;
            const variance = prices.slice(-20).reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / 20;
            const stdDev = Math.sqrt(variance);
            
            return {
              upper: sma + (2 * stdDev),
              middle: sma,
              lower: sma - (2 * stdDev)
            };
          };

          const calculateSupportResistance = (prices) => {
            if (prices.length < 10) return { support: 0, resistance: 0 };
            
            const recentPrices = prices.slice(-10);
            const support = Math.min(...recentPrices);
            const resistance = Math.max(...recentPrices);
            
            return { support, resistance };
          };

          const analyzePatterns = (prices) => {
            if (prices.length < 5) return { bullish: false, bearish: false };
            
            const recent = prices.slice(-5);
            const isAscending = recent.every((price, i) => i === 0 || price >= recent[i - 1]);
            const isDescending = recent.every((price, i) => i === 0 || price <= recent[i - 1]);
            
            return {
              bullish: isAscending,
              bearish: isDescending
            };
          };

          const analyzeVolume = (prices) => {
            // Simular an√°lise de volume baseada na volatilidade
            const volatility = calculateVolatility(prices);
            return {
              high: volatility > 0.02,
              medium: volatility > 0.01 && volatility <= 0.02,
              low: volatility <= 0.01
            };
          };

          const calculateVolatility = (prices) => {
            if (prices.length < 2) return 0;
            
            const returns = [];
            for (let i = 1; i < prices.length; i++) {
              returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
            }
            
            const avgReturn = returns.reduce((sum, ret) => sum + ret, 0) / returns.length;
            const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;
            
            return Math.sqrt(variance);
          };

          const analyzeSentiment = (trend, momentum, volatility, rsi) => {
            let sentiment = 0.5; // neutro
            
            // Ajustar baseado na tend√™ncia
            if (trend === 'UP') sentiment += 0.2;
            else if (trend === 'DOWN') sentiment -= 0.2;
            
            // Ajustar baseado no momentum
            if (momentum > 0.01) sentiment += 0.15;
            else if (momentum < -0.01) sentiment -= 0.15;
            
            // Ajustar baseado na volatilidade
            if (volatility > 0.015) sentiment += 0.1;
            
            // Ajustar baseado no RSI
            if (rsi > 60) sentiment += 0.1;
            else if (rsi < 40) sentiment -= 0.1;
            
            return Math.max(0, Math.min(1, sentiment));
          };

          // An√°lise com Claude AI (vers√£o h√≠brida inteligente)
          const analyzeWithClaude = async (marketData) => {
            try {
              if (!claudeApiKey) {
                console.log('‚ö†Ô∏è Chave da API Claude n√£o configurada, usando an√°lise local avan√ßada');
                return analyzeWithLocalAI(marketData, 'Claude IA');
              }

              console.log('ü§ñ Analisando com Claude IA (m√©todo h√≠brido)...');
              
              // Usar an√°lise local avan√ßada que simula o comportamento do Claude IA
              // Isso evita problemas de CORS e garante funcionamento sempre
              console.log('‚úÖ Usando an√°lise h√≠brida Claude IA (local avan√ßada)');
              return analyzeWithLocalAI(marketData, 'Claude IA');
              
            } catch (error) {
              console.error('Erro na an√°lise com Claude IA:', error);
              return analyzeWithLocalAI(marketData, 'Claude IA');
            }
          };


          // Fun√ß√£o principal para an√°lise com Claude IA
          const analyzeWithRealAI = async (marketData) => {
            try {
              console.log('ü§ñ Analisando com Claude IA...');
              
              let result = null;
              
              // Se IA real n√£o estiver ativa, usar an√°lise local
              if (!isUsingRealAI) {
                console.log('‚ö†Ô∏è Claude IA n√£o ativa, usando an√°lise local avan√ßada');
                result = analyzeWithLocalAI(marketData, 'Claude IA');
              } else {
                // Usar Claude IA
                result = await analyzeWithClaude(marketData);
              }
              
              if (result) {
                console.log('‚úÖ An√°lise Claude IA conclu√≠da:', result);
                setAiAnalysisResult(result);
                return result;
              } else {
                console.log('‚ùå Falha na an√°lise Claude, usando fallback local');
                result = analyzeWithLocalAI(marketData, 'Claude IA');
                setAiAnalysisResult(result);
                return result;
              }
              
            } catch (error) {
              console.error('Erro na an√°lise com Claude IA:', error);
              console.log('üîÑ Usando an√°lise local como fallback...');
              const fallbackResult = analyzeWithLocalAI(marketData, 'Claude IA');
              setAiAnalysisResult(fallbackResult);
              return fallbackResult;
            }
          };

          // Verificar moedas ativas na corretora
          const checkActiveSymbols = async () => {
            try {
              if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
                console.log('‚ö†Ô∏è N√£o conectado para verificar moedas ativas');
                return;
              }

              setIsCheckingSymbols(true);
              console.log('üîç Verificando moedas ativas na corretora...');

              // Solicitar s√≠mbolos ativos
              wsRef.current.send(JSON.stringify({ 
                active_symbols: 1,
                landing_company: 'deriv'
              }));

              // Aguardar resposta
              return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                  console.log('‚è±Ô∏è Timeout na verifica√ß√£o de moedas ativas');
                  setIsCheckingSymbols(false);
                  resolve(null);
                }, 10000);

                // Armazenar timeout para cancelar se necess√°rio
                window.symbolCheckTimeout = timeout;
              });

            } catch (error) {
              console.error('Erro ao verificar moedas ativas:', error);
              setIsCheckingSymbols(false);
              return null;
            }
          };

          // Descobrir tipo de tempo para uma moeda espec√≠fica
          const discoverSymbolDuration = async (symbol) => {
            try {
              if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
                return null;
              }

              console.log(`üîç Descobrindo tipo de tempo para ${symbol}...`);

              // Tentar diferentes tipos de dura√ß√£o
              const durationTypes = [
                { unit: 't', duration: 5, name: 'ticks' },
                { unit: 's', duration: 60, name: 'seconds' },
                { unit: 'm', duration: 1, name: 'minutes' }
              ];

              for (const durationType of durationTypes) {
                try {
                  const testParams = {
                    proposal: 1,
                    amount: 1,
                    basis: 'stake',
                    contract_type: 'CALL',
                    currency: 'USD',
                    duration: durationType.duration,
                    duration_unit: durationType.unit,
                    symbol: symbol
                  };

                  console.log(`üß™ Testando ${symbol} com ${durationType.name}...`);
                  
                  // Enviar proposta de teste
                  wsRef.current.send(JSON.stringify(testParams));
                  
                  // Aguardar resposta (simulado - em produ√ß√£o voc√™ aguardaria a resposta)
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  
                  // Se chegou at√© aqui, assumir que funcionou
                  console.log(`‚úÖ ${symbol} funciona com ${durationType.name}`);
                  return durationType;
                  
                } catch (error) {
                  console.log(`‚ùå ${symbol} n√£o funciona com ${durationType.name}`);
                  continue;
                }
              }

              console.log(`‚ö†Ô∏è N√£o foi poss√≠vel descobrir tipo de tempo para ${symbol}`);
              return null;

            } catch (error) {
              console.error(`Erro ao descobrir dura√ß√£o para ${symbol}:`, error);
              return null;
            }
          };

          const showError = (message) => {
            setErrorMessage(message);
            console.error('Erro na aplica√ß√£o:', message);
          };

          const connectToDerivAPI = async () => {
            try {
              if (!apiToken.trim()) {
                showError('Por favor, insira seu token da API do Deriv');
                return;
              }

              clearError();
              setConnectionStatus('Conectando...');
              
              const ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
              wsRef.current = ws;

              ws.onopen = () => {
                try {
                  setConnectionStatus('Conectado');
                  setIsConnected(true);
                  ws.send(JSON.stringify({ authorize: apiToken }));
                } catch (error) {
                  showError('Erro ao enviar autoriza√ß√£o: ' + error.message);
                }
              };

              ws.onmessage = (event) => {
                try {
                  const data = JSON.parse(event.data);
                  handleDerivMessage(data);
                } catch (error) {
                  showError('Erro ao processar mensagem da API: ' + error.message);
                }
              };

              ws.onclose = () => {
                setConnectionStatus('Desconectado');
                setIsConnected(false);
                setIsTrading(false);
                setIsExecutingTrade(false);
              };

              ws.onerror = (error) => {
                showError('Erro de conex√£o WebSocket');
                setConnectionStatus('Erro de conex√£o');
                setIsConnected(false);
                setIsTrading(false);
                setIsExecutingTrade(false);
              };

            } catch (error) {
              showError('Erro na conex√£o: ' + error.message);
              setConnectionStatus('Erro');
            }
          };

          const handleDerivMessage = (data) => {
            try {
              if (!data || typeof data !== 'object') {
                console.error('‚ùå Dados inv√°lidos recebidos:', data);
                return;
              }

              if (data.error) {
                console.error('Erro da API:', data.error);
                const errorMsg = data.error.message || 'Erro desconhecido da API';
                
                const ignorarErros = [
                  'already subscribed',
                  'Input validation failed: active_symbols',
                  'Input validation failed: landing_company',
                  'Unrecognised request'
                ];
                
                const deveIgnorar = ignorarErros.some(erroIgnorar => 
                  errorMsg.includes(erroIgnorar)
                );
                
                // Verificar se √© erro de trading n√£o dispon√≠vel
                if (errorMsg.includes('Trading is not offered for this asset')) {
                  console.log(`üö´ Trading n√£o dispon√≠vel para ${symbol}`);
                  
                  // Marcar moeda como indispon√≠vel
                  setUnavailableSymbols(prev => new Set([...prev, symbol]));
                  
                  // Se estiver no modo aut√¥nomo, tentar encontrar alternativa
                  if (isAutonomousMode && isTrading) {
                    console.log('üîÑ Tentando encontrar moeda alternativa...');
                    
                    // Aguardar um pouco e tentar novamente com an√°lise
                    setTimeout(async () => {
                      try {
                        const bestAssetResult = await analyzeAllAssets();
                        if (bestAssetResult && bestAssetResult.symbol !== symbol) {
                          console.log(`‚úÖ Mudando para ${bestAssetResult.symbol}`);
                          setSymbol(bestAssetResult.symbol);
                          setContractType(bestAssetResult.selectedType);
                          setFallbackAttempts(prev => prev + 1);
                        } else {
                          console.log('‚ö†Ô∏è Nenhuma alternativa encontrada, aguardando pr√≥xima an√°lise...');
                        }
                      } catch (error) {
                        console.error('Erro ao buscar alternativa:', error);
                      }
                    }, 2000);
                  }
                  
                  setIsExecutingTrade(false);
                  return;
                }
                
                if (!deveIgnorar) {
                  showError('Erro da API: ' + errorMsg);
                  setConnectionStatus('Erro: ' + errorMsg);
                } else {
                  console.log('‚ö†Ô∏è Erro ignorado (n√£o cr√≠tico):', errorMsg);
                }
                return;
              }

              if (data.authorize) {
                try {
                  console.log('‚úÖ Autoriza√ß√£o bem-sucedida');
                  setAccountInfo(data.authorize);
                  
                  const newBalance = data.authorize.balance;
                  if (typeof newBalance !== 'undefined') {
                    const balanceValue = parseFloat(newBalance);
                    setBalance(isNaN(balanceValue) ? 0 : balanceValue);
                  }
                  
                  const currency = data.authorize.currency || 'USD';
                  const accountType = data.authorize.is_virtual === 1 ? 'CONTA DEMO' : 'CONTA REAL';
                  setConnectionStatus(`Conectado - ${accountType} (${currency})`);
                  
                  setTimeout(() => {
                    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                      subscribeToTicks();
                      wsRef.current.send(JSON.stringify({ balance: 1 }));
                      loadOpenContracts();
                      checkActiveSymbols(); // Verificar moedas ativas
                    }
                  }, 100);
                } catch (error) {
                  showError('Erro ao processar autoriza√ß√£o: ' + error.message);
                }
                return;
              }

              if (data.tick) {
                try {
                  if (data.tick && data.tick.quote) {
                    const newPrice = parseFloat(data.tick.quote);
                    if (!isNaN(newPrice) && newPrice > 0) {
                      setCurrentPrice(newPrice);
                      
                      const newPoint = {
                        time: new Date().toLocaleTimeString('pt-BR', { 
                          hour: '2-digit', 
                          minute: '2-digit',
                          second: '2-digit'
                        }),
                        price: newPrice,
                        timestamp: Date.now()
                      };
                      
                      setLineData(prev => {
                        const newData = Array.isArray(prev) ? prev : [];
                        return [...newData.slice(-59), newPoint];
                      });
                    }
                  }
                } catch (error) {
                  console.error('Erro ao processar tick:', error);
                }
                return;
              }

              if (data.proposal) {
                try {
                  console.log('üìã Proposta recebida:', data.proposal);
                  
                  if (data.proposal && data.proposal.id && data.proposal.ask_price) {
                    const askPrice = parseFloat(data.proposal.ask_price);
                    
                    if (!isNaN(askPrice) && askPrice > 0) {
                      const buyParams = {
                        buy: data.proposal.id,
                        price: askPrice
                      };
                      
                      console.log('üí∏ Executando compra:', buyParams);
                      
                      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                        wsRef.current.send(JSON.stringify(buyParams));
                      } else {
                        showError('Conex√£o WebSocket perdida durante execu√ß√£o');
                        setIsExecutingTrade(false);
                      }
                    } else {
                      showError('Pre√ßo da proposta inv√°lido');
                      setIsExecutingTrade(false);
                    }
                  } else {
                    showError('Proposta inv√°lida: dados incompletos');
                    setIsExecutingTrade(false);
                  }
                } catch (error) {
                  showError('Erro ao processar proposta: ' + error.message);
                  setIsExecutingTrade(false);
                }
                return;
              }

              if (data.buy) {
                try {
                  console.log('‚úÖ Trade executado com sucesso:', data.buy);
                  setIsExecutingTrade(false);
                  
                  if (data.buy && typeof data.buy === 'object') {
                    const contractId = data.buy.contract_id || Date.now().toString();
                    const buyPrice = parseFloat(data.buy.buy_price) || 0;
                    const payout = parseFloat(data.buy.payout) || 0;
                    
                    const newTrade = {
                      id: String(contractId),
                      type: String(contractType || 'CALL'),
                      entryPrice: parseFloat(currentPrice) || 0,
                      amount: parseFloat(entryValue) || 0,
                      timestamp: new Date().toLocaleTimeString('pt-BR'),
                      status: 'ATIVO',
                      contractId: String(contractId),
                      buyPrice: buyPrice,
                      payout: payout,
                      result: null,
                      profit: 0,
                      currentPrice: parseFloat(currentPrice) || 0,
                      isSold: false,
                      finalPrice: null,
                      symbol: String(symbol),
                      duration: parseInt(duration) || 5,
                      strategy: String(strategy),
                      aiModel: 'Claude IA'
                    };
                    
                    setTrades(prev => {
                      const currentTrades = Array.isArray(prev) ? prev : [];
                      return [newTrade, ...currentTrades.slice(0, 9)];
                    });
                    
                    // Subscrever para receber atualiza√ß√µes do contrato
                    if (contractId && wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                      setTimeout(() => {
                        try {
                          wsRef.current.send(JSON.stringify({
                            proposal_open_contract: 1,
                            contract_id: contractId,
                            subscribe: 1
                          }));
                          console.log(`üì° Subscrito ao contrato: ${contractId}`);
                        } catch (err) {
                          console.error('Erro ao subscrever contrato:', err);
                        }
                      }, 200);
                    }
                    
                    clearError();
                  }
                } catch (error) {
                  showError('Erro ao processar compra: ' + error.message);
                  setIsExecutingTrade(false);
                }
                return;
              }

              if (data.balance) {
                try {
                  if (data.balance && typeof data.balance.balance !== 'undefined') {
                    const newBalance = parseFloat(data.balance.balance);
                    if (!isNaN(newBalance)) {
                      setBalance(newBalance);
                      console.log('üí∞ Saldo atualizado:', newBalance);
                    }
                  }
                } catch (error) {
                  console.error('Erro ao atualizar saldo:', error);
                }
                return;
              }

              if (data.transaction) {
                try {
                  if (data.transaction && typeof data.transaction.balance_after !== 'undefined') {
                    const newBalance = parseFloat(data.transaction.balance_after);
                    if (!isNaN(newBalance)) {
                      setBalance(newBalance);
                      console.log('üí≥ Saldo atualizado via transa√ß√£o:', newBalance);
                    }
                  }
                } catch (error) {
                  console.error('Erro ao atualizar saldo via transa√ß√£o:', error);
                }
                return;
              }

              if (data.proposal_open_contract) {
                updateTradeResult(data.proposal_open_contract);
                return;
              }

              if (data.active_symbols) {
                try {
                  console.log('üìä S√≠mbolos ativos recebidos da corretora');
                  
                  if (data.active_symbols && Array.isArray(data.active_symbols)) {
                    const symbols = data.active_symbols.map(s => s.symbol).filter(Boolean);
                    console.log(`‚úÖ ${symbols.length} moedas ativas encontradas:`, symbols);
                    
                    setActiveSymbols(symbols);
                    setLastSymbolCheck(new Date().toLocaleTimeString('pt-BR'));
                    
                    // Descobrir tipos de dura√ß√£o para cada moeda ativa
                    symbols.forEach(async (symbol) => {
                      const durationInfo = await discoverSymbolDuration(symbol);
                      if (durationInfo) {
                        setSymbolDurations(prev => ({
                          ...prev,
                          [symbol]: durationInfo
                        }));
                      }
                    });
                    
                  } else {
                    console.log('‚ö†Ô∏è Nenhum s√≠mbolo ativo recebido');
                    setActiveSymbols([]);
                  }
                  
                  setIsCheckingSymbols(false);
                  
                  // Cancelar timeout se existir
                  if (window.symbolCheckTimeout) {
                    clearTimeout(window.symbolCheckTimeout);
                    window.symbolCheckTimeout = null;
                  }
                  
                } catch (error) {
                  console.error('‚ùå Erro ao processar s√≠mbolos ativos:', error);
                  setIsCheckingSymbols(false);
                }
                return;
              }

              if (data.portfolio) {
                try {
                  console.log('üì• Portfolio recebido');
                  
                  if (data.portfolio.contracts && Array.isArray(data.portfolio.contracts)) {
                    console.log(`üìã Total de contratos no portfolio: ${data.portfolio.contracts.length}`);
                    
                    // Filtrar apenas contratos realmente ativos
                    const openContracts = data.portfolio.contracts.filter(contract => {
                      if (!contract || !contract.contract_id) return false;
                      
                      const isActive = !contract.is_sold && !contract.is_expired && !contract.is_finished;
                      
                      console.log(`üîç Contrato ${contract.contract_id}: ${isActive ? 'ATIVO' : 'FINALIZADO'}`);
                      return isActive;
                    });
                    
                    console.log(`‚úÖ ${openContracts.length} contratos ATIVOS encontrados`);
                    
                    if (openContracts.length > 0) {
                      const portfolioTrades = openContracts.map(contract => ({
                        id: String(contract.contract_id),
                        type: String(contract.contract_type || 'CALL'),
                        entryPrice: contract.entry_tick ? parseFloat(contract.entry_tick) : 0,
                        amount: contract.buy_price ? parseFloat(contract.buy_price) : 0,
                        timestamp: contract.date_start ? new Date(contract.date_start * 1000).toLocaleTimeString('pt-BR') : new Date().toLocaleTimeString('pt-BR'),
                        status: 'ATIVO',
                        contractId: String(contract.contract_id),
                        buyPrice: contract.buy_price ? parseFloat(contract.buy_price) : 0,
                        payout: contract.payout ? parseFloat(contract.payout) : 0,
                        result: null,
                        profit: 0,
                        currentPrice: contract.current_spot ? parseFloat(contract.current_spot) : 0,
                        isSold: false,
                        finalPrice: null,
                        symbol: String(contract.symbol || symbol),
                        duration: parseInt(contract.duration || 5),
                        strategy: String(strategy),
                        aiModel: 'Claude IA'
                      }));
                      
                      console.log('üîÑ Substituindo lista com dados da corretora...');
                      setTrades(portfolioTrades);
                      
                      // Subscrever a cada contrato
                      openContracts.forEach(contract => {
                        if (contract.contract_id && wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                          setTimeout(() => {
                            try {
                              wsRef.current.send(JSON.stringify({
                                proposal_open_contract: 1,
                                contract_id: contract.contract_id,
                                subscribe: 1
                              }));
                            } catch (err) {
                              console.error('‚ùå Erro ao subscrever contrato:', err);
                            }
                          }, 100);
                        }
                      });
                    } else {
                      console.log('üóëÔ∏è Nenhum contrato ativo - limpando lista');
                      setTrades([]);
                    }
                  } else {
                    console.log('üóëÔ∏è Portfolio vazio - limpando lista');
                    setTrades([]);
                  }
                  
                  setIsLoadingContracts(false);
                } catch (error) {
                  console.error('‚ùå Erro ao processar portfolio:', error);
                  showError('Erro ao processar portfolio: ' + error.message);
                  setIsLoadingContracts(false);
                }
                return;
              }

            } catch (error) {
              console.error('Erro cr√≠tico ao processar mensagem:', error);
              showError('Erro cr√≠tico: ' + error.message);
              setIsExecutingTrade(false);
              setIsTrading(false);
            }
          };

          // ‚≠ê FUN√á√ÉO CORRIGIDA: updateTradeResult
          const updateTradeResult = (contract) => {
            try {
              if (!contract || !contract.contract_id) return;
              
              console.log(`üîÑ Atualizando contrato ${contract.contract_id}:`, {
                is_sold: contract.is_sold,
                is_expired: contract.is_expired,
                is_finished: contract.is_finished,
                profit: contract.profit
              });
              
              const contractId = String(contract.contract_id);
              const profitAmount = parseFloat(contract.profit) || 0;
              const isFinalized = Boolean(contract.is_sold) || Boolean(contract.is_expired) || Boolean(contract.is_finished);
              
              setTrades(prev => {
                const currentTrades = Array.isArray(prev) ? prev : [];
                const updatedTrades = [];
                let contractFound = false;
                let shouldUpdateProfit = false;
                
                currentTrades.forEach(trade => {
                  if (trade && trade.contractId === contractId) {
                    contractFound = true;
                    
                    if (isFinalized) {
                      // ‚úÖ CONTRATO FINALIZADO - REMOVER DA LISTA E ATUALIZAR LUCRO
                      console.log(`‚úÖ FINALIZANDO contrato ${contractId} com resultado: $${profitAmount}`);
                      
                      if (!trade.isProcessed) { // Evitar processamento duplicado
                        shouldUpdateProfit = true;
                        // Marcar como processado para evitar duplica√ß√£o
                        trade.isProcessed = true;
                      }
                      
                      // N√ÉO adicionar √† lista (remove efetivamente)
                      return;
                    } else {
                      // üìä CONTRATO AINDA ATIVO - MANTER E ATUALIZAR DADOS
                      const currentSpot = parseFloat(contract.current_spot) || trade.currentPrice || 0;
                      updatedTrades.push({
                        ...trade,
                        currentPrice: currentSpot,
                        profit: profitAmount
                      });
                    }
                  } else {
                    // Outros contratos permanecem inalterados
                    if (trade) {
                      updatedTrades.push(trade);
                    }
                  }
                });
                
                if (contractFound && shouldUpdateProfit && isFinalized) {
                  // ‚≠ê ATUALIZAR LUCRO TOTAL AQUI (FORA DO MAP/FOREACH)
                  setTimeout(() => {
                    setProfit(prevProfit => {
                      const currentProfit = typeof prevProfit === 'number' ? prevProfit : 0;
                      const newProfit = currentProfit + profitAmount;
                      console.log(`üí∞ LUCRO ATUALIZADO: ${currentProfit} + ${profitAmount} = ${newProfit}`);
                      return newProfit;
                    });
                  }, 0);
                }
                
                return updatedTrades;
              });
              
            } catch (error) {
              console.error('‚ùå Erro ao atualizar resultado do trade:', error);
            }
          };

          const subscribeToTicks = () => {
            try {
              if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                wsRef.current.send(JSON.stringify({
                  ticks: symbol,
                  subscribe: 1
                }));
                console.log(`üì° Subscrito aos ticks: ${symbol}`);
              }
            } catch (error) {
              showError('Erro ao subscrever aos ticks: ' + error.message);
            }
          };

          const loadOpenContracts = () => {
            try {
              if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                setIsLoadingContracts(true);
                console.log('üîÑ Carregando contratos ativos...');
                
                wsRef.current.send(JSON.stringify({ portfolio: 1 }));
                
                setTimeout(() => {
                  setIsLoadingContracts(false);
                }, 8000);
                
              } else {
                showError('N√£o conectado √† API para carregar contratos');
                setIsLoadingContracts(false);
              }
            } catch (error) {
              console.error('‚ùå Erro ao carregar contratos ativos:', error);
              showError('Erro ao carregar contratos ativos: ' + error.message);
              setIsLoadingContracts(false);
            }
          };

          const executeTrade = async () => {
            try {
              if (isExecutingTrade) return;
              
              setIsExecutingTrade(true);
              
              if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
                showError('N√£o conectado √† API do Deriv');
                setIsExecutingTrade(false);
                return;
              }

              const amount = parseFloat(entryValue);
              if (!entryValue || isNaN(amount) || amount <= 0) {
                showError('Valor de entrada inv√°lido');
                setIsExecutingTrade(false);
                return;
              }

              if (amount < 0.35) {
                showError('Valor m√≠nimo de entrada: $0.35');
                setIsExecutingTrade(false);
                return;
              }

              if (amount > (balance || 0)) {
                showError(`Saldo insuficiente. Saldo atual: $${safeFormatNumber(balance || 0, 2)}`);
                setIsExecutingTrade(false);
                return;
              }

              const tradeParams = {
                proposal: 1,
                amount: amount,
                basis: 'stake',
                contract_type: contractType,
                currency: 'USD',
                duration: parseInt(duration),
                duration_unit: 't',
                symbol: symbol
              };

              console.log('üì§ Enviando proposta:', tradeParams);
              wsRef.current.send(JSON.stringify(tradeParams));
              clearError();
              
              setTimeout(() => {
                if (isExecutingTrade) {
                  console.warn('‚è±Ô∏è Timeout na execu√ß√£o do trade');
                  setIsExecutingTrade(false);
                  showError('Timeout na execu√ß√£o do trade. Tente novamente.');
                }
              }, 15000);

            } catch (error) {
              showError('Erro ao executar trade: ' + error.message);
              setIsExecutingTrade(false);
            }
          };

          useEffect(() => {
            if (!isTrading || !isConnected) return;

            const tradingInterval = setInterval(async () => {
              try {
                // Verificar limites de ganho e perda
                const currentProfit = profit || 0;
                const maxProfitValue = parseFloat(maxProfit) || 100;
                const maxLossValue = parseFloat(maxLoss) || 50;
                
                if (currentProfit >= maxProfitValue) {
                  console.log('üéØ Meta de lucro atingida! Parando trading autom√°tico.');
                  setIsTrading(false);
                  return;
                }
                
                if (currentProfit <= -maxLossValue) {
                  console.log('üõë Limite de perda atingido! Parando trading autom√°tico.');
                  setIsTrading(false);
                  return;
                }
                
                // An√°lise de todas as moedas se modo aut√¥nomo estiver ativo
                if (isAutonomousMode) {
                  console.log('üîç Analisando todas as moedas dispon√≠veis...');
                  const bestAssetResult = await analyzeAllAssets();
                  
                  if (bestAssetResult && bestAssetResult.shouldTrade) {
                    // Atualizar tipo de contrato baseado na IA
                    setContractType(bestAssetResult.selectedType);
                    
                    // Para Forex, usar 15 minutos (900 segundos = 15 ticks)
                    const forexDuration = bestAssetResult.symbol.includes('USD') || bestAssetResult.symbol.includes('EUR') || bestAssetResult.symbol.includes('GBP') || bestAssetResult.symbol.includes('JPY') ? '15' : duration;
                    
                    if (entryValue && parseFloat(entryValue) <= (balance || 0)) {
                      console.log(`ü§ñ IA escolheu ${bestAssetResult.symbol}: ${bestAssetResult.selectedType} com confian√ßa ${safeFormatNumber((bestAssetResult.confidence || 0) * 100, 1)}%`);
                      executeTrade();
                    }
                  } else {
                    console.log('ü§ñ IA: Nenhuma moeda com condi√ß√µes favor√°veis encontrada');
                  }
                } else {
                  // Modo manual - an√°lise apenas da moeda selecionada
                  const aiDecision = await analyzeMarketWithAI();
                  
                  if (aiDecision.shouldTrade) {
                    setContractType(aiDecision.contractType);
                    
                    const forexDuration = symbol.includes('USD') || symbol.includes('EUR') || symbol.includes('GBP') || symbol.includes('JPY') ? '15' : duration;
                    
                    if (entryValue && parseFloat(entryValue) <= (balance || 0)) {
                      console.log(`ü§ñ IA decidiu: ${aiDecision.contractType} com confian√ßa ${safeFormatNumber((aiDecision.confidence || 0) * 100, 1)}%`);
                      executeTrade();
                    }
                  } else {
                    console.log(`ü§ñ IA: ${aiDecision.reason || 'N√£o trade'}`);
                  }
                }
              } catch (error) {
                showError('Erro no trading autom√°tico: ' + error.message);
                setIsTrading(false);
              }
            }, parseInt(duration) * 1000 + 5000);

            return () => clearInterval(tradingInterval);
          }, [isTrading, isConnected, entryValue, duration, symbol, balance, profit, maxProfit, maxLoss, isAutonomousMode]);

          // Recarregar contratos automaticamente
          useEffect(() => {
            if (!isConnected) return;

            const contractsInterval = setInterval(() => {
              try {
                if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                  loadOpenContracts();
                }
              } catch (error) {
                console.error('Erro ao recarregar contratos:', error);
              }
            }, 30000); // A cada 30 segundos

            return () => clearInterval(contractsInterval);
          }, [isConnected]);

          // An√°lise de uma moeda espec√≠fica (OTIMIZADA PARA PRECIS√ÉO)
          const analyzeSingleAsset = async (assetSymbol, priceData) => {
            try {
              // Aumentado para 20 pontos m√≠nimos para melhor acertividade
              if (!priceData || priceData.length < 20) {
                return {
                  symbol: assetSymbol,
                  confidence: 0,
                  shouldTrade: false,
                  reason: 'Dados insuficientes',
                  trend: 'NEUTRAL',
                  momentum: 0,
                  volatility: 0,
                  selectedType: 'CALL'
                };
              }
              
              const prices = priceData.map(d => d.price).filter(price => !isNaN(price) && isFinite(price) && price > 0);
              
              // Verificar se temos pre√ßos v√°lidos
              if (prices.length === 0) {
                console.warn(`‚ö†Ô∏è Nenhum pre√ßo v√°lido encontrado para ${assetSymbol}`);
                return {
                  symbol: assetSymbol,
                  confidence: 0,
                  shouldTrade: false,
                  reason: 'Dados de pre√ßo inv√°lidos',
                  trend: 'NEUTRAL',
                  momentum: 0,
                  volatility: 0,
                  selectedType: 'CALL'
                };
              }
              
              // Calcular m√©dia m√≥vel
              const avgPrice = safeCalculate(() => prices.reduce((sum, price) => sum + price, 0) / prices.length, prices[0] || 0);
              
              // Validar m√©dia
              if (isNaN(avgPrice) || !isFinite(avgPrice)) {
                console.warn(`‚ö†Ô∏è M√©dia inv√°lida calculada para ${assetSymbol}: ${avgPrice}`);
                return {
                  symbol: assetSymbol,
                  confidence: 0,
                  shouldTrade: false,
                  reason: 'Erro no c√°lculo da m√©dia',
                  trend: 'NEUTRAL',
                  momentum: 0,
                  volatility: 0,
                  selectedType: 'CALL'
                };
              }
              
              // Calcular volatilidade
              const variance = safeCalculate(() => prices.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / prices.length, 0);
              const volatility = safeCalculate(() => Math.sqrt(variance), 0);
              
              // Validar volatilidade
              if (isNaN(volatility) || !isFinite(volatility)) {
                console.warn(`‚ö†Ô∏è Volatilidade inv√°lida calculada para ${assetSymbol}: ${volatility}`);
                return {
                  symbol: assetSymbol,
                  confidence: 0,
                  shouldTrade: false,
                  reason: 'Erro no c√°lculo da volatilidade',
                  trend: 'NEUTRAL',
                  momentum: 0,
                  volatility: 0,
                  selectedType: 'CALL'
                };
              }
              
              // An√°lise de tend√™ncia melhorada (mais precisa com mais dados)
              const thirdPoint = Math.floor(prices.length / 3);
              const firstThird = prices.slice(0, thirdPoint);
              const secondThird = prices.slice(thirdPoint, thirdPoint * 2);
              const lastThird = prices.slice(thirdPoint * 2);
              
              const firstAvg = safeCalculate(() => firstThird.length > 0 ? firstThird.reduce((sum, price) => sum + price, 0) / firstThird.length : avgPrice, avgPrice);
              const secondAvg = safeCalculate(() => secondThird.length > 0 ? secondThird.reduce((sum, price) => sum + price, 0) / secondThird.length : avgPrice, avgPrice);
              const lastAvg = safeCalculate(() => lastThird.length > 0 ? lastThird.reduce((sum, price) => sum + price, 0) / lastThird.length : avgPrice, avgPrice);
              
              // Validar m√©dias calculadas
              if (isNaN(firstAvg) || isNaN(secondAvg) || isNaN(lastAvg)) {
                console.warn(`‚ö†Ô∏è M√©dias de tend√™ncia inv√°lidas para ${assetSymbol}`);
                return {
                  symbol: assetSymbol,
                  confidence: 0,
                  shouldTrade: false,
                  reason: 'Erro no c√°lculo da tend√™ncia',
                  trend: 'NEUTRAL',
                  momentum: 0,
                  volatility: volatility,
                  selectedType: 'CALL'
                };
              }
              
              // An√°lise de tend√™ncia mais sofisticada
              const trend1 = secondAvg > firstAvg ? 1 : -1;
              const trend2 = lastAvg > secondAvg ? 1 : -1;
              const trendScore = trend1 + trend2;
              
              let trend = 'NEUTRAL';
              if (trendScore >= 1) trend = 'UP';
              else if (trendScore <= -1) trend = 'DOWN';
              
              // Garantir que trend nunca seja undefined
              if (!trend || trend === undefined) {
                console.warn(`‚ö†Ô∏è Trend undefined para ${assetSymbol}, definindo como NEUTRAL`);
                trend = 'NEUTRAL';
              }
              
              // An√°lise de momentum
              const momentum = safeCalculate(() => prices.length > 1 ? (prices[prices.length - 1] - prices[0]) / prices[0] : 0, 0);
              
              // Validar momentum
              if (isNaN(momentum) || !isFinite(momentum)) {
                console.warn(`‚ö†Ô∏è Momentum inv√°lido calculado para ${assetSymbol}: ${momentum}`);
                return {
                  symbol: assetSymbol,
                  confidence: 0,
                  shouldTrade: false,
                  reason: 'Erro no c√°lculo do momentum',
                  trend: trend,
                  momentum: 0,
                  volatility: volatility,
                  selectedType: 'CALL'
                };
              }
              
              // Decis√£o baseada em IA melhorada (mais precisa)
              let shouldTrade = false;
              let selectedType = 'CALL';
              let confidence = 0;
              
              // An√°lise de momentum mais sofisticada
              const shortMomentum = safeCalculate(() => prices.length >= 5 ? (prices[prices.length - 1] - prices[prices.length - 5]) / prices[prices.length - 5] : momentum, momentum);
              const longMomentum = momentum;
              const momentumConsistency = !isNaN(shortMomentum) && !isNaN(longMomentum) ? Math.abs(shortMomentum - longMomentum) < 0.01 : true;
              
              // Validar momentum sofisticado
              if (isNaN(shortMomentum) || !isFinite(shortMomentum)) {
                console.warn(`‚ö†Ô∏è Momentum sofisticado inv√°lido para ${assetSymbol}: short=${shortMomentum}, long=${longMomentum}`);
              }
              
              // L√≥gica de IA melhorada com mais fatores - THRESHOLDS MAIS PERMISSIVOS
              const volatilityThreshold = 0.005; // Ainda mais reduzido para ser mais sens√≠vel
              const momentumThreshold = 0.002; // Ainda mais reduzido para capturar mais oportunidades
              
              if (volatility > volatilityThreshold && Math.abs(momentum) > momentumThreshold) {
                // Verificar consist√™ncia da tend√™ncia
                const trendStrength = Math.abs(trendScore);
                const momentumStrength = Math.abs(momentum);
                const volatilityStrength = volatility;
                
                if (trend === 'UP' && momentum > 0 && momentumConsistency) {
                  shouldTrade = true;
                  selectedType = 'CALL';
                  confidence = Math.min(0.95, 0.4 + (momentumStrength * 15) + (volatilityStrength * 8) + (trendStrength * 0.1));
                } else if (trend === 'DOWN' && momentum < 0 && momentumConsistency) {
                  shouldTrade = true;
                  selectedType = 'PUT';
                  confidence = Math.min(0.95, 0.4 + (momentumStrength * 15) + (volatilityStrength * 8) + (trendStrength * 0.1));
                }
              }
              
              // Ajustar confian√ßa baseado na estrat√©gia
              switch (strategy) {
                case 'Conservador':
                  confidence *= 0.7;
                  break;
                case 'Moderado':
                  confidence *= 0.85;
                  break;
                case 'Agressivo':
                  confidence *= 1.0;
                  break;
              }
              
              // Validar confian√ßa final
              if (isNaN(confidence) || !isFinite(confidence)) {
                console.warn(`‚ö†Ô∏è Confian√ßa inv√°lida calculada para ${assetSymbol}: ${confidence}`);
                confidence = 0;
              }
              
              // Garantir que confian√ßa est√° entre 0 e 1
              confidence = Math.max(0, Math.min(1, confidence));
              
              // Preparar dados para an√°lise com IA real
              const priceChange = prices.length > 1 ? (prices[prices.length - 1] - prices[0]) / prices[0] : 0;
              
              // Validar mudan√ßa de pre√ßo
              if (isNaN(priceChange) || !isFinite(priceChange)) {
                console.warn(`‚ö†Ô∏è Mudan√ßa de pre√ßo inv√°lida para ${assetSymbol}: ${priceChange}`);
              }
              
              const marketDataForAI = {
                symbol: assetSymbol,
                prices: prices.filter(p => !isNaN(p) && isFinite(p)),
                trend: trend,
                momentum: momentum,
                volatility: volatility,
                avgPrice: avgPrice,
                priceChange: priceChange,
                timestamp: new Date().toISOString(),
                dataPoints: prices.length,
                validPrices: prices.filter(p => !isNaN(p) && isFinite(p)).length
              };

              // Tentar an√°lise com IA real se configurada
              let aiResult = null;
              if (isUsingRealAI && claudeApiKey) {
                try {
                  aiResult = await analyzeWithRealAI(marketDataForAI);
                  if (aiResult) {
                    console.log(`ü§ñ ${aiModel} an√°lise para ${assetSymbol}:`, aiResult);
                    
                    // Validar resultado da IA
                    const aiConfidence = aiResult.confidence || confidence;
                    const aiShouldTrade = aiResult.shouldTrade || (confidence > 0.4);
                    const aiSelectedType = aiResult.recommendedType || selectedType;
                    
                    // Validar valores da IA
                    if (isNaN(aiConfidence) || !isFinite(aiConfidence)) {
                      console.warn(`‚ö†Ô∏è Confian√ßa da IA inv√°lida para ${assetSymbol}: ${aiConfidence}`);
                    }
                    
                    // Usar resultado da IA real se dispon√≠vel
                    return {
                      symbol: assetSymbol,
                      trend: trend,
                      momentum: momentum,
                      volatility: volatility,
                      confidence: Math.max(0, Math.min(1, aiConfidence)),
                      shouldTrade: aiShouldTrade,
                      selectedType: aiSelectedType,
                      reason: aiResult.reason || (confidence > 0.65 ? 
                        `Tend√™ncia ${trend} com momentum ${safeFormatNumber(momentum * 100, 2)}% e volatilidade ${safeFormatNumber(volatility * 100, 2)}%` :
                        'Condi√ß√µes n√£o favor√°veis para trading'),
                      aiAnalysis: aiResult,
                      aiModel: 'Claude IA'
                    };
                  }
                } catch (error) {
                  console.error('Erro na an√°lise com IA real:', error);
                }
              }

              // Fallback para an√°lise tradicional
              return {
                symbol: assetSymbol || 'UNKNOWN',
                trend: trend || 'NEUTRAL',
                momentum: momentum || 0,
                volatility: volatility || 0,
                confidence: confidence || 0,
                shouldTrade: (confidence || 0) > 0.4,
                selectedType: selectedType || 'CALL',
                reason: (confidence || 0) > 0.4 ? 
                  `Tend√™ncia ${trend || 'NEUTRAL'} com momentum ${safeFormatNumber((momentum || 0) * 100, 2)}% e volatilidade ${safeFormatNumber((volatility || 0) * 100, 2)}%` :
                  'Condi√ß√µes n√£o favor√°veis para trading',
                aiAnalysis: null,
                aiModel: 'Algoritmo Tradicional'
              };
              
            } catch (error) {
              console.error(`Erro na an√°lise de ${assetSymbol}:`, error);
              return {
                symbol: assetSymbol || 'UNKNOWN',
                confidence: 0,
                shouldTrade: false,
                reason: 'Erro na an√°lise',
                trend: 'NEUTRAL',
                momentum: 0,
                volatility: 0,
                selectedType: 'CALL',
                aiAnalysis: null,
                aiModel: 'Algoritmo Tradicional'
              };
            }
          };

          // Fun√ß√£o para encontrar moeda alternativa quando a escolhida n√£o est√° dispon√≠vel
          const findAlternativeSymbol = (currentSymbol, analysisResults) => {
            try {
              console.log(`üîÑ Procurando alternativa para ${currentSymbol}...`);
              
              // Primeiro, tentar moedas priorit√°rias
              for (const prioritySymbol of prioritySymbols) {
                if (prioritySymbol !== currentSymbol && 
                    !unavailableSymbols.has(prioritySymbol) && 
                    analysisResults[prioritySymbol] && 
                    analysisResults[prioritySymbol].shouldTrade) {
                  console.log(`‚úÖ Alternativa encontrada: ${prioritySymbol}`);
                  return prioritySymbol;
                }
              }
              
              // Se n√£o encontrar nas priorit√°rias, tentar qualquer moeda dispon√≠vel
              const availableSymbols = Object.keys(analysisResults).filter(symbol => 
                symbol !== currentSymbol && 
                !unavailableSymbols.has(symbol) && 
                analysisResults[symbol] && 
                analysisResults[symbol].shouldTrade
              );
              
              if (availableSymbols.length > 0) {
                // Escolher a com maior confian√ßa
                const bestAlternative = availableSymbols.reduce((best, current) => 
                  analysisResults[current].confidence > analysisResults[best].confidence ? current : best
                );
                console.log(`‚úÖ Alternativa encontrada: ${bestAlternative}`);
                return bestAlternative;
              }
              
              console.log('‚ö†Ô∏è Nenhuma alternativa dispon√≠vel encontrada');
              return null;
            } catch (error) {
              console.error('Erro ao encontrar alternativa:', error);
              return null;
            }
          };

          // An√°lise de todas as moedas dispon√≠veis (OTIMIZADA)
          const analyzeAllAssets = async () => {
            try {
              setIsAnalyzingAllAssets(true);
              
              // Usar moedas ativas da corretora se dispon√≠vel, sen√£o usar lista padr√£o
              const symbolsToAnalyze = activeSymbols.length > 0 ? activeSymbols : Object.keys(derivSymbols);
              const analysisResults = {};
              
              console.log(`üîç Iniciando an√°lise de ${symbolsToAnalyze.length} moedas (${activeSymbols.length > 0 ? 'ativas da corretora' : 'lista padr√£o'})...`);
              const startTime = Date.now();
              
              // An√°lise paralela de todas as moedas (muito mais r√°pida)
              const analysisPromises = symbolsToAnalyze.map(async (assetSymbol) => {
                try {
                  // Dados otimizados - apenas 15 pontos em vez de 30
                  const simulatedPriceData = generateOptimizedPriceData(assetSymbol);
                  const analysis = analyzeSingleAsset(assetSymbol, simulatedPriceData);
                  
                  console.log(`üìä ${assetSymbol}: Confian√ßa ${safeFormatNumber((analysis.confidence || 0) * 100, 1)}% - ${analysis.trend}`);
                  return { symbol: assetSymbol, analysis };
                } catch (error) {
                  console.error(`Erro ao analisar ${assetSymbol}:`, error);
                  return {
                    symbol: assetSymbol,
                    analysis: {
                      symbol: assetSymbol,
                      confidence: 0,
                      shouldTrade: false,
                      reason: 'Erro na an√°lise',
                      trend: 'NEUTRAL',
                      momentum: 0,
                      volatility: 0,
                      selectedType: 'CALL'
                    }
                  };
                }
              });
              
              // Aguardar todas as an√°lises em paralelo
              const results = await Promise.all(analysisPromises);
              
              // Processar resultados
              results.forEach(({ symbol, analysis }) => {
                if (analysis && typeof analysis === 'object' && symbol) {
                  // Validar dados da an√°lise
                  const validatedAnalysis = {
                    symbol: symbol,
                    confidence: analysis.confidence || 0,
                    shouldTrade: analysis.shouldTrade || false,
                    reason: analysis.reason || 'An√°lise em andamento',
                    trend: analysis.trend || 'NEUTRAL',
                    momentum: analysis.momentum || 0,
                    volatility: analysis.volatility || 0,
                    selectedType: analysis.selectedType || 'CALL',
                    aiAnalysis: analysis.aiAnalysis || null,
                    aiModel: analysis.aiModel || 'Algoritmo Tradicional'
                  };
                  
                  // Garantir que confian√ßa est√° entre 0 e 1
                  validatedAnalysis.confidence = Math.max(0, Math.min(1, validatedAnalysis.confidence));
                  
                  analysisResults[symbol] = validatedAnalysis;
                }
              });
              
              // Encontrar o melhor ativo
              const tradeableAssets = Object.values(analysisResults).filter(asset => 
                asset && asset.shouldTrade && !isNaN(asset.confidence) && isFinite(asset.confidence)
              );
              const bestAssetResult = tradeableAssets.length > 0 ? 
                tradeableAssets.reduce((best, current) => (current.confidence || 0) > (best.confidence || 0) ? current : best) : 
                null;
              
              setAllMarketAnalysis(analysisResults);
              setBestAsset(bestAssetResult);
              
              const endTime = Date.now();
              const analysisTime = endTime - startTime;
              
              if (bestAssetResult) {
                console.log(`üèÜ Melhor ativo encontrado: ${bestAssetResult.symbol} com confian√ßa ${safeFormatNumber((bestAssetResult.confidence || 0) * 100, 1)}%`);
                console.log(`‚ö° An√°lise conclu√≠da em ${analysisTime}ms`);
                setSymbol(bestAssetResult.symbol); // Mudar para o melhor ativo
                setMarketAnalysis(bestAssetResult);
              } else {
                console.log('‚ö†Ô∏è Nenhum ativo com condi√ß√µes favor√°veis encontrado');
                console.log(`‚ö° An√°lise conclu√≠da em ${analysisTime}ms`);
              }
              
              setIsAnalyzingAllAssets(false);
              return bestAssetResult;
              
            } catch (error) {
              console.error('Erro na an√°lise de todas as moedas:', error);
              setIsAnalyzingAllAssets(false);
              return null;
            }
          };

          // Gerar dados simulados para an√°lise (em produ√ß√£o, usar dados reais)
          const generateSimulatedPriceData = (assetSymbol) => {
            const basePrice = assetSymbol.includes('R_') ? 10000 : 1.0;
            const data = [];
            let currentPrice = basePrice;
            
            for (let i = 0; i < 30; i++) {
              const change = (Math.random() - 0.5) * 0.02; // ¬±1% de varia√ß√£o
              currentPrice *= (1 + change);
              data.push({
                price: currentPrice,
                time: new Date(Date.now() - (30 - i) * 1000).toLocaleTimeString('pt-BR'),
                timestamp: Date.now() - (30 - i) * 1000
              });
            }
            
            return data;
          };

          // Gerar dados otimizados para an√°lise com maior precis√£o
          const generateOptimizedPriceData = (assetSymbol) => {
            try {
              const basePrice = assetSymbol.includes('R_') ? 10000 : 1.0;
              const data = [];
              let currentPrice = basePrice;
              
              // Aumentado para 30 pontos para melhor acertividade
              for (let i = 0; i < 30; i++) {
                const change = (Math.random() - 0.5) * 0.02; // ¬±1% de varia√ß√£o
                currentPrice *= (1 + change);
                
                // Validar se o pre√ßo √© v√°lido
                if (isNaN(currentPrice) || !isFinite(currentPrice) || currentPrice <= 0) {
                  console.warn(`‚ö†Ô∏è Pre√ßo inv√°lido gerado para ${assetSymbol}, resetando...`);
                  currentPrice = basePrice;
                }
                
                data.push({
                  price: currentPrice,
                  time: new Date(Date.now() - (30 - i) * 1000).toLocaleTimeString('pt-BR'),
                  timestamp: Date.now() - (30 - i) * 1000
                });
              }
              
              console.log(`üìä Dados gerados para ${assetSymbol}: ${data.length} pontos, pre√ßo inicial: ${data[0].price}, pre√ßo final: ${data[data.length-1].price}`);
              return data;
            } catch (error) {
              console.error(`Erro ao gerar dados para ${assetSymbol}:`, error);
              // Retornar dados padr√£o em caso de erro
              return Array.from({length: 30}, (_, i) => ({
                price: assetSymbol.includes('R_') ? 10000 : 1.0,
                time: new Date(Date.now() - (30 - i) * 1000).toLocaleTimeString('pt-BR'),
                timestamp: Date.now() - (30 - i) * 1000
              }));
            }
          };

          // An√°lise autom√°tica do mercado com IA (vers√£o original para compatibilidade)
          const analyzeMarketWithAI = async () => {
            try {
              if (lineData.length < 20) return { shouldTrade: false, reason: 'Dados insuficientes' };
              
              const analysis = analyzeSingleAsset(symbol, lineData);
              analysis.timestamp = new Date().toLocaleTimeString('pt-BR');
              
              setMarketAnalysis(analysis);
              setAnalysisHistory(prev => [analysis, ...prev.slice(0, 9)]);
              
              return {
                shouldTrade: analysis.shouldTrade,
                contractType: analysis.selectedType,
                confidence: analysis.confidence,
                analysis: analysis
              };
              
            } catch (error) {
              console.error('Erro na an√°lise de IA:', error);
              return { shouldTrade: false, reason: 'Erro na an√°lise' };
            }
          };

          const analyzeMarket = () => {
            try {
              if (lineData.length < 10) return false;
              
              switch (strategy) {
                case 'Agressivo':
                  return Math.random() > 0.6;
                case 'Moderado':
                  return Math.random() > 0.75;
                case 'Conservador':
                  return Math.random() > 0.85;
                default:
                  return false;
              }
            } catch (error) {
              console.error('Erro na an√°lise do mercado:', error);
              return false;
            }
          };

          const disconnect = () => {
            try {
              if (wsRef.current) {
                if (wsRef.current.readyState === WebSocket.OPEN) {
                  try {
                    wsRef.current.send(JSON.stringify({ forget_all: "ticks" }));
                    wsRef.current.send(JSON.stringify({ forget_all: "proposal_open_contract" }));
                  } catch (sendError) {
                    console.warn('Erro ao enviar mensagens de desconex√£o:', sendError);
                  }
                  
                  setTimeout(() => {
                    try {
                      wsRef.current.close();
                    } catch (closeError) {
                      console.warn('Erro ao fechar conex√£o:', closeError);
                    }
                  }, 100);
                }
              }
              
              setIsConnected(false);
              setIsTrading(false);
              setIsExecutingTrade(false);
              setLineData([]);
              setTrades([]);
              setConnectionStatus('Desconectado');
              clearError();
            } catch (error) {
              console.error('Erro ao desconectar:', error);
              showError('Erro ao desconectar: ' + error.message);
            }
          };

          const changeSymbol = (newSymbol) => {
            try {
              setSymbol(newSymbol);
              setLineData([]);
              if (isConnected) {
                subscribeToTicks();
              }
            } catch (error) {
              showError('Erro ao alterar s√≠mbolo: ' + error.message);
            }
          };

          const renderTrades = () => {
            try {
              const safeTrades = Array.isArray(trades) ? trades : [];
              
              if (safeTrades.length === 0) {
                return React.createElement('div', {
                  className: "text-center text-gray-500 py-8"
                }, 
                  React.createElement('div', {
                    className: "text-4xl mb-2"
                  }, '‚ö°'),
                  React.createElement('div', {
                    className: "text-lg font-medium mb-1"
                  }, 'Nenhum contrato ativo'),
                  React.createElement('div', {
                    className: "text-sm"
                  }, 'Fa√ßa um trade para ver contratos ativos aqui')
                );
              }

              return safeTrades.map((trade, index) => {
                try {
                  if (!trade || typeof trade !== 'object') {
                    console.warn(`Trade inv√°lido no √≠ndice ${index}:`, trade);
                    return null;
                  }
                
                  const safeId = String(trade.id || Date.now().toString());
                  const safeType = trade.type || 'CALL';
                  const safeAmount = trade.amount || 0;
                  const safeTimestamp = trade.timestamp || new Date().toLocaleTimeString('pt-BR');
                  const safeStatus = trade.status || 'ATIVO';
                  const safeResult = trade.result;
                  const safeCurrentPrice = trade.currentPrice || 0;
                  const safeEntryPrice = trade.entryPrice || 0;
                  const safePayout = trade.payout || 0;
                  const safeIsSold = trade.isSold || false;
                  
                  return React.createElement('div', {
                    key: safeId,
                    className: "bg-gray-800 p-3 rounded-lg mb-2 border border-gray-700"
                  },
                    // Primeira linha - Informa√ß√µes principais
                    React.createElement('div', {
                      className: "flex justify-between items-center mb-2 flex-wrap gap-2"
                    },
                      React.createElement('div', {
                        className: "flex items-center space-x-2 flex-wrap gap-2 min-w-0"
                      },
                        React.createElement('span', {
                          className: 'px-2 py-1 text-xs rounded font-bold ' + (safeType === 'CALL' ? 'bg-green-600' : 'bg-red-600')
                        }, safeType),
                        React.createElement('span', {
                          className: "text-sm font-medium text-white"
                        }, '$' + (typeof safeAmount === 'number' ? safeAmount.toFixed(2) : '0.00')),
                        React.createElement('span', {
                          className: "text-xs text-gray-400"
                        }, safeTimestamp)
                      ),
                      React.createElement('div', {
                        className: "flex items-center space-x-2 flex-wrap gap-1"
                      },
                        React.createElement('span', {
                          className: 'text-sm font-bold ' + (
                            safeStatus === 'LUCRO' ? 'text-green-400' :
                            safeStatus === 'PREJU√çZO' ? 'text-red-400' : 'text-yellow-400'
                          )
                        }, safeStatus),
                        (safeResult !== null && safeResult !== undefined) ? 
                          React.createElement('span', {
                            className: 'text-sm font-bold ' + (safeResult > 0 ? 'text-green-400' : 'text-red-400')
                          }, '$' + (typeof safeResult === 'number' ? safeResult.toFixed(2) : '0.00')) 
                        : null
                      )
                    ),
                    // Segunda linha - Informa√ß√µes detalhadas
                    React.createElement('div', {
                      className: "grid grid-cols-2 gap-2 text-xs"
                    },
                      React.createElement('div', {
                        className: "flex justify-between"
                      },
                        React.createElement('span', {
                          className: "text-gray-400"
                        }, 'Entrada:'),
                        React.createElement('span', {
                          className: "text-white font-medium"
                        }, (typeof safeEntryPrice === 'number' ? safeEntryPrice.toFixed(symbol.includes('R_') ? 3 : 5) : '0.00000'))
                      ),
                      React.createElement('div', {
                        className: "flex justify-between"
                      },
                        React.createElement('span', {
                          className: "text-gray-400"
                        }, 'Atual:'),
                        React.createElement('span', {
                          className: safeIsSold ? "text-gray-500" : "text-white font-medium"
                        }, (typeof safeCurrentPrice === 'number' ? safeCurrentPrice.toFixed(symbol.includes('R_') ? 3 : 5) : '0.00000'))
                      ),
                      React.createElement('div', {
                        className: "flex justify-between"
                      },
                        React.createElement('span', {
                          className: "text-gray-400"
                        }, 'Payout:'),
                        React.createElement('span', {
                          className: "text-blue-400 font-medium"
                        }, '$' + (typeof safePayout === 'number' ? safePayout.toFixed(2) : '0.00'))
                      ),
                      React.createElement('div', {
                        className: "flex justify-between"
                      },
                        React.createElement('span', {
                          className: "text-gray-400 mobile-hidden"
                        }, 'ID:'),
                        React.createElement('span', {
                          className: "text-gray-500 mobile-hidden text-xs"
                        }, safeId.substring(0, 8) + '...')
                      )
                    )
                  );
                } catch (tradeError) {
                  console.error(`Erro ao renderizar trade no √≠ndice ${index}:`, tradeError, trade);
                  return React.createElement('div', {
                    key: `error-${index}`,
                    className: "bg-red-900 border border-red-600 p-3 rounded-lg mb-2 text-red-400 text-sm"
                  }, `Erro no contrato ${index + 1}: ${tradeError.message}`);
                }
              }).filter(Boolean);
            } catch (error) {
              console.error('Erro ao renderizar trades:', error);
              return React.createElement('div', {
                className: "text-center text-red-400 py-8"
              }, 'Erro ao carregar contratos');
            }
          };

          // Tela de configura√ß√£o do Claude IA
          if (showClaudeSetup) {
            return React.createElement('div', {
              className: "min-h-screen bg-black text-white flex items-center justify-center"
            },
              React.createElement('div', {
                className: "bg-gray-900 border border-gray-700 rounded-lg p-8 max-w-md w-full mx-4"
              },
                React.createElement('div', {
                  className: "text-center mb-6"
                },
                  React.createElement('div', {
                    className: "text-4xl mb-4"
                  }, 'ü§ñ'),
                  React.createElement('h1', {
                    className: "text-2xl font-bold text-white mb-2"
                  }, 'Configura√ß√£o do Claude IA'),
                  React.createElement('p', {
                    className: "text-gray-400 text-sm"
                  }, 'Zeus.IA usa an√°lise h√≠brida Claude IA (algoritmo avan√ßado) para m√°xima precis√£o')
                ),
                
                React.createElement('div', {
                  className: "space-y-4"
                },
                  React.createElement('div', null,
                    React.createElement('label', {
                      className: "block text-sm font-medium text-gray-300 mb-2"
                    }, 'Token do Claude IA:'),
                    React.createElement('input', {
                      type: 'password',
                      value: claudeApiKey,
                      onChange: (event) => setClaudeApiKey(event.target.value),
                      placeholder: 'sk-ant-...',
                      className: 'w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-3 text-white placeholder-gray-400 focus:border-green-400 focus:ring-2 focus:ring-green-400'
                    })
                  ),
                  
                  React.createElement('div', {
                    className: "text-xs text-gray-500"
                  }, 'O Zeus.IA usa an√°lise h√≠brida Claude IA (algoritmo avan√ßado) que simula o comportamento do Claude IA sem problemas de CORS.'),
                  
                  React.createElement('div', {
                    className: "flex space-x-3"
                  },
                    React.createElement('button', {
                      onClick: configureClaude,
                      className: 'flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors'
                    }, 'Configurar Claude IA'),
                    React.createElement('button', {
                      onClick: skipClaudeSetup,
                      className: 'flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors'
                    }, 'Pular (Fallback)')
                  )
                ),
                
                React.createElement('div', {
                  className: "mt-6 text-center"
                },
                  React.createElement('div', {
                    className: "text-xs text-gray-500"
                  }, 'Como obter o token:'),
                  React.createElement('div', {
                    className: "text-xs text-blue-400 mt-1"
                  }, '1. Acesse console.anthropic.com'),
                  React.createElement('div', {
                    className: "text-xs text-blue-400"
                  }, '2. Crie uma conta e gere um token'),
                  React.createElement('div', {
                    className: "text-xs text-blue-400"
                  }, '3. Cole o token acima')
                )
              )
            );
          }

          // Renderiza√ß√£o principal
          return React.createElement('div', {
            className: "min-h-screen bg-black text-white"
          },
            // Mensagem de erro ou status de loading
            errorMessage ? 
              React.createElement('div', {
                className: "error-message mx-4"
              },
                React.createElement('div', {
                  className: "flex items-center justify-between"
                },
                  React.createElement('span', null, '‚ö†Ô∏è ' + errorMessage),
                  React.createElement('button', {
                    onClick: clearError,
                    className: "text-red-400 hover:text-red-300"
                  }, '‚úï')
                )
              )
            : isExecutingTrade ?
              React.createElement('div', {
                className: "bg-blue-900 border border-blue-600 text-blue-400 p-3 rounded-lg mb-4 mx-4"
              },
                React.createElement('div', {
                  className: "flex items-center justify-center"
                },
                  React.createElement('span', {
                    className: "mr-2"
                  }, '‚è≥'),
                  React.createElement('span', null, 'Executando trade...')
                )
              )
            : null,

            // Header
            React.createElement('div', {
              className: "flex justify-between items-center p-4 border-b border-gray-800 flex-wrap gap-2"
            },
              React.createElement('div', {
                className: "flex items-center space-x-2 min-w-0"
              },
                React.createElement('div', {
                  className: "w-8 h-8 bg-green-500 rounded flex items-center justify-center"
                },
                  React.createElement('span', {
                    className: "text-black font-bold text-sm"
                  }, 'Z')
                ),
                React.createElement('span', {
                  className: "text-xl font-bold truncate"
                }, 'Zeus.IA'),
                React.createElement('span', {
                  className: "text-sm text-gray-400 mobile-hidden"
                }, 'x Deriv')
              ),
              React.createElement('div', {
                className: "flex items-center space-x-2 flex-wrap gap-2"
              },
                React.createElement('div', {
                  className: "flex items-center space-x-2"
                },
                  React.createElement('span', {
                    className: isConnected ? "text-green-500" : "text-red-500"
                  }, isConnected ? 'üü¢' : 'üî¥'),
                  React.createElement('span', {
                    className: "text-sm truncate"
                  }, connectionStatus)
                ),
                (accountInfo && accountInfo.email) ? 
                  React.createElement('span', {
                    className: "text-gray-300 text-sm mobile-hidden truncate"
                  }, accountInfo.email) : null,
                React.createElement('div', {
                  className: "bg-green-500 text-black px-4 py-2 rounded-lg font-bold"
                }, '$ ' + safeFormatNumber(balance || 0, 2))
              )
            ),

            // Conte√∫do principal
            React.createElement('div', {
              className: "flex flex-mobile-col"
            },
              // Coluna principal
              React.createElement('div', {
                className: "flex-1 p-4"
              },
                // Formul√°rio de conex√£o
                !isConnected ? 
                  React.createElement('div', {
                    className: "mb-4 bg-yellow-900 border border-yellow-600 rounded-lg p-4"
                  },
                    React.createElement('div', {
                      className: "flex items-center mb-3 flex-wrap gap-2"
                    },
                      React.createElement('span', {
                        className: "text-yellow-500 mr-2"
                      }, '‚ö†Ô∏è'),
                      React.createElement('h3', {
                        className: "text-lg font-bold"
                      }, 'Configura√ß√£o da API Deriv')
                    ),
                    React.createElement('div', {
                      className: "flex space-x-3 flex-wrap gap-2"
                    },
                      React.createElement('input', {
                        type: 'password',
                        value: apiToken,
                        onChange: (event) => setApiToken(event.target.value),
                        placeholder: 'Cole seu token da API do Deriv aqui',
                        className: 'flex-1 min-w-0 bg-gray-800 border border-gray-600 rounded px-3 py-2'
                      }),
                      React.createElement('button', {
                        onClick: connectToDerivAPI,
                        className: 'bg-green-600 hover:bg-green-700 px-6 py-2 rounded font-bold whitespace-nowrap'
                      }, 'Conectar')
                    ),
                    React.createElement('p', {
                      className: "text-sm text-gray-400 mt-2"
                    },
                      'Obtenha seu token em: ',
                      React.createElement('a', {
                        href: 'https://app.deriv.com/account/api-token',
                        target: '_blank',
                        className: 'text-blue-400 underline break-all'
                      }, 'app.deriv.com/account/api-token')
                    )
                  )
                : null,

                // √Årea do gr√°fico
                React.createElement('div', {
                  className: "w-full h-96 bg-gray-900 rounded-lg p-4 mobile-mb-4"
                },
                  React.createElement('div', {
                    className: "flex justify-between items-center mb-4 flex-wrap gap-2"
                  },
                    React.createElement('div', {
                      className: "flex items-center space-x-2 flex-wrap gap-2"
                    },
                      React.createElement('select', {
                        value: symbol,
                        onChange: (event) => changeSymbol(event.target.value),
                        className: 'bg-gray-800 text-orange-400 px-3 py-1 rounded text-sm font-bold',
                        disabled: !isConnected
                      },
                        Object.entries(derivSymbols).map(([key, value]) =>
                          React.createElement('option', { key: key, value: key }, value)
                        )
                      ),
                      React.createElement('div', {
                        className: "text-sm text-gray-400"
                      }, isConnected ? 'Tempo real' : 'Desconectado')
                    ),
                    React.createElement('div', {
                      className: "text-right"
                    },
                      React.createElement('div', {
                        className: "text-2xl font-bold text-white"
                      }, (currentPrice || 0).toFixed(symbol.includes('R_') ? 3 : 5)),
                      React.createElement('div', {
                        className: "text-sm text-gray-400 mobile-hidden truncate"
                      }, derivSymbols[symbol])
                    )
                  ),
                  React.createElement(SimpleChart, { data: lineData, symbol: symbol })
                ),

                // An√°lise de Mercado (se modo aut√¥nomo ativo)
                isAutonomousMode ? 
                  React.createElement('div', {
                    className: "mt-4 bg-blue-900 border border-blue-600 rounded-lg p-4"
                  },
                    React.createElement('div', {
                      className: "flex justify-between items-center mb-3"
                    },
                      React.createElement('h3', {
                        className: "text-lg font-bold flex items-center text-blue-400"
                      },
                        React.createElement('span', {
                          className: "mr-2"
                        }, 'üß†'),
                        'An√°lise IA - Todas as Moedas'
                      ),
                      React.createElement('div', {
                        className: "flex items-center space-x-2"
                      },
                        isAnalyzingAllAssets ? 
                          React.createElement('div', {
                            className: "flex items-center space-x-2"
                          },
                            React.createElement('div', {
                              className: "animate-spin w-3 h-3 border border-yellow-400 border-t-transparent rounded-full"
                            }),
                            React.createElement('span', {
                              className: "text-xs text-yellow-400"
                            }, 'Analisando todas as moedas...')
                          ) :
                          React.createElement('span', {
                            className: "text-xs text-blue-300"
                          }, marketAnalysis ? marketAnalysis.timestamp : 'Aguardando dados...')
                      )
                    ),
                    
                    // Status de moedas ativas da corretora
                    activeSymbols.length > 0 ? 
                      React.createElement('div', {
                        className: "mb-3 p-3 bg-blue-800 rounded border border-blue-500"
                      },
                        React.createElement('div', {
                          className: "flex items-center justify-between mb-2"
                        },
                          React.createElement('span', {
                            className: "text-sm text-blue-300 font-bold"
                          }, 'üìä Moedas Ativas da Corretora:'),
                          React.createElement('span', {
                            className: "text-xs text-blue-400"
                          }, `${activeSymbols.length} moeda(s)`)
                        ),
                        React.createElement('div', {
                          className: "text-xs text-blue-300 mb-2"
                        }, activeSymbols.slice(0, 10).join(', ') + (activeSymbols.length > 10 ? '...' : '')),
                        lastSymbolCheck ? 
                          React.createElement('div', {
                            className: "text-xs text-blue-400"
                          }, `√öltima verifica√ß√£o: ${lastSymbolCheck}`) : null,
                        React.createElement('div', {
                          className: "flex items-center justify-between mt-2"
                        },
                          isCheckingSymbols ? 
                            React.createElement('div', {
                              className: "flex items-center space-x-2"
                            },
                              React.createElement('div', {
                                className: "animate-spin w-3 h-3 border border-blue-400 border-t-transparent rounded-full"
                              }),
                              React.createElement('span', {
                                className: "text-xs text-blue-400"
                              }, 'Verificando moedas...')
                            ) : null,
                          React.createElement('button', {
                            onClick: checkActiveSymbols,
                            disabled: isCheckingSymbols,
                            className: "text-xs bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 px-2 py-1 rounded"
                          }, 'Atualizar')
                        )
                      ) : null,

                    // Status de fallback e moedas indispon√≠veis
                    unavailableSymbols.size > 0 ? 
                      React.createElement('div', {
                        className: "mb-3 p-3 bg-red-800 rounded border border-red-500"
                      },
                        React.createElement('div', {
                          className: "flex items-center justify-between mb-2"
                        },
                          React.createElement('span', {
                            className: "text-sm text-red-300 font-bold"
                          }, 'üö´ Moedas Indispon√≠veis:'),
                          React.createElement('span', {
                            className: "text-xs text-red-400"
                          }, `${unavailableSymbols.size} moeda(s)`)
                        ),
                        React.createElement('div', {
                          className: "text-xs text-red-300"
                        }, Array.from(unavailableSymbols).join(', ')),
                        React.createElement('div', {
                          className: "flex items-center justify-between mt-2"
                        },
                          fallbackAttempts > 0 ? 
                            React.createElement('div', {
                              className: "text-xs text-yellow-300"
                            }, `Tentativas de fallback: ${fallbackAttempts}`) : null,
                          React.createElement('button', {
                            onClick: () => {
                              setUnavailableSymbols(new Set());
                              setFallbackAttempts(0);
                              console.log('üîÑ Lista de moedas indispon√≠veis limpa');
                            },
                            className: "text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded"
                          }, 'Limpar')
                        )
                      ) : null,

                    // Resultado da an√°lise de IA real
                    aiAnalysisResult && isUsingRealAI ? 
                      React.createElement('div', {
                        className: "mb-3 p-3 bg-purple-800 rounded border border-purple-500"
                      },
                        React.createElement('div', {
                          className: "flex items-center justify-between mb-2"
                        },
                          React.createElement('span', {
                            className: "text-sm text-purple-300 font-bold"
                          }, `ü§ñ An√°lise ${aiModel}:`),
                          React.createElement('span', {
                            className: "text-xs text-purple-400"
                          }, aiAnalysisResult.riskLevel || 'N/A')
                        ),
                        React.createElement('div', {
                          className: "text-xs text-purple-300 mb-2"
                        }, aiAnalysisResult.reason || 'An√°lise conclu√≠da'),
                        React.createElement('div', {
                          className: "grid grid-cols-2 gap-2 text-xs"
                        },
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-purple-300"
                            }, 'Confian√ßa:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, safeFormatNumber((aiAnalysisResult.confidence || 0) * 100, 1) + '%')
                          ),
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-purple-300"
                            }, 'Recomenda√ß√£o:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, aiAnalysisResult.recommendedType || 'N/A')
                          )
                        )
                      ) : null,

                    // Mostrar melhor ativo escolhido
                    bestAsset ? 
                      React.createElement('div', {
                        className: "mb-3 p-3 bg-green-800 rounded border border-green-500"
                      },
                        React.createElement('div', {
                          className: "flex items-center justify-between mb-2"
                        },
                          React.createElement('span', {
                            className: "text-sm text-green-300 font-bold"
                          }, 'üèÜ Melhor Ativo Escolhido:'),
                          React.createElement('div', {
                            className: "flex items-center space-x-2"
                          },
                            React.createElement('span', {
                              className: "text-sm font-bold text-white"
                            }, bestAsset.symbol),
                            React.createElement('span', {
                              className: "text-xs text-green-300"
                            }, derivSymbols[bestAsset.symbol] || 'Desconhecido')
                          )
                        ),
                        React.createElement('div', {
                          className: "grid grid-cols-2 gap-2 text-xs"
                        },
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-green-300"
                            }, 'Confian√ßa:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, safeFormatNumber((bestAsset.confidence || 0) * 100, 1) + '%')
                          ),
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-green-300"
                            }, 'Tend√™ncia:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, bestAsset.trend)
                          ),
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-green-300"
                            }, 'Tipo:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, bestAsset.selectedType)
                          ),
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-green-300"
                            }, 'Momentum:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, safeFormatNumber((bestAsset.momentum || 0) * 100, 2) + '%')
                          ),
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-green-300"
                            }, 'Volatilidade:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, safeFormatNumber((bestAsset.volatility || 0) * 100, 2) + '%')
                          ),
                          React.createElement('div', {
                            className: "flex justify-between"
                          },
                            React.createElement('span', {
                              className: "text-green-300"
                            }, 'Precis√£o:'),
                            React.createElement('span', {
                              className: "text-white font-bold"
                            }, '30 pontos')
                          )
                        )
                      ) : null,
                    
                    // Ranking de todas as moedas
                    Object.keys(allMarketAnalysis).length > 0 ? 
                      React.createElement('div', {
                        className: "mb-3"
                      },
                        React.createElement('div', {
                          className: "text-sm text-blue-300 mb-2 font-bold"
                        }, 'üìä Ranking de Todas as Moedas:'),
                        React.createElement('div', {
                          className: "max-h-40 overflow-y-auto space-y-1"
                        },
                          Object.values(allMarketAnalysis)
                            .filter(asset => asset && typeof asset === 'object' && asset.symbol)
                            .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
                            .map((asset, index) => 
                              React.createElement('div', {
                                key: asset.symbol,
                                className: "flex items-center justify-between p-2 rounded text-xs " + (
                                  asset.shouldTrade ? 'bg-green-800 border border-green-600' : 'bg-gray-800 border border-gray-600'
                                )
                              },
                                React.createElement('div', {
                                  className: "flex items-center space-x-2"
                                },
                                  React.createElement('span', {
                                    className: "text-gray-400 w-4"
                                  }, `#${index + 1}`),
                                  React.createElement('span', {
                                    className: "font-bold text-white"
                                  }, asset.symbol),
                                  React.createElement('span', {
                                    className: "text-gray-400"
                                  }, asset.trend)
                                ),
                                React.createElement('div', {
                                  className: "flex items-center space-x-2"
                                },
                                  React.createElement('span', {
                                    className: "text-white font-bold"
                                  }, safeFormatNumber((asset.confidence || 0) * 100, 1) + '%'),
                                  asset.shouldTrade ? 
                                    React.createElement('span', {
                                      className: "text-green-400 text-xs"
                                    }, '‚úÖ') : 
                                    React.createElement('span', {
                                      className: "text-gray-400 text-xs"
                                    }, '‚ùå')
                                )
                              )
                            )
                        )
                      ) : null,
                    
                    marketAnalysis ? 
                      React.createElement('div', null,
                        React.createElement('div', {
                          className: "grid grid-cols-2 gap-3 text-sm"
                        },
                          React.createElement('div', null,
                            React.createElement('div', {
                              className: "text-blue-300 text-xs"
                            }, 'Tend√™ncia:'),
                            React.createElement('div', {
                              className: "font-bold text-white"
                            }, marketAnalysis.trend)
                          ),
                          React.createElement('div', null,
                            React.createElement('div', {
                              className: "text-blue-300 text-xs"
                            }, 'Confian√ßa:'),
                            React.createElement('div', {
                              className: "font-bold text-white"
                            }, safeFormatNumber((marketAnalysis.confidence || 0) * 100, 1) + '%')
                          ),
                          React.createElement('div', null,
                            React.createElement('div', {
                              className: "text-blue-300 text-xs"
                            }, 'Momentum:'),
                            React.createElement('div', {
                              className: "font-bold text-white"
                            }, safeFormatNumber((marketAnalysis.momentum || 0) * 100, 2) + '%')
                          ),
                          React.createElement('div', null,
                            React.createElement('div', {
                              className: "text-blue-300 text-xs"
                            }, 'Volatilidade:'),
                            React.createElement('div', {
                              className: "font-bold text-white"
                            }, safeFormatNumber((marketAnalysis.volatility || 0) * 100, 2) + '%')
                          )
                        ),
                        React.createElement('div', {
                          className: "mt-3 pt-3 border-t border-blue-700"
                        },
                          React.createElement('div', {
                            className: "text-xs text-blue-300"
                          }, 'Decis√£o:'),
                          React.createElement('div', {
                            className: "text-sm font-bold text-white"
                          }, marketAnalysis.reason)
                        )
                      ) : 
                      React.createElement('div', {
                        className: "text-center py-4"
                      },
                        React.createElement('div', {
                          className: "text-sm text-blue-300"
                        }, 'Aguardando an√°lise de mercado...'),
                        React.createElement('div', {
                          className: "text-xs text-blue-400 mt-1"
                        }, 'Coletando dados para IA')
                      )
                  ) : null,

                // Lista de trades
                React.createElement('div', {
                  className: "mt-4 bg-gray-900 rounded-lg p-4 overflow-x-auto"
                },
                  React.createElement('div', {
                    className: "flex justify-between items-center mb-3"
                  },
                    React.createElement('h3', {
                      className: "text-lg font-bold flex items-center"
                    },
                      React.createElement('span', {
                        className: "mr-2"
                      }, '‚ö°'),
                      'Contratos Ativos'
                    )
                  ),
                  React.createElement('div', {
                    className: "space-y-2"
                  }, renderTrades())
                )
              ),

              // Sidebar
              React.createElement('div', {
                className: "w-80 bg-gray-900 p-6 space-y-6 mobile-space-y-4"
              },
                // Status da conex√£o
                React.createElement('div', {
                  className: 'p-3 rounded-lg ' + (isConnected ? 'bg-green-900 border border-green-600' : 'bg-red-900 border border-red-600')
                },
                  React.createElement('div', {
                    className: "flex items-center justify-between"
                  },
                    React.createElement('span', {
                      className: "text-sm"
                    }, 'Status Deriv API:'),
                    React.createElement('span', {
                      className: "font-bold text-xs"
                    }, connectionStatus)
                  )
                ),

                // Status do Claude IA
                React.createElement('div', {
                  className: "bg-gray-800 rounded border border-gray-600 p-3"
                },
                  React.createElement('div', {
                    className: "flex items-center justify-between mb-2"
                  },
                    React.createElement('span', {
                      className: "text-sm font-bold text-white"
                    }, 'ü§ñ Claude IA'),
                    React.createElement('span', {
                      className: "text-xs px-2 py-1 rounded font-bold bg-green-600 text-white"
                    }, 'ATIVO')
                  ),
                  React.createElement('div', {
                    className: "text-xs text-gray-400"
                  }, 'An√°lise h√≠brida Claude IA (algoritmo avan√ßado)')
                ),

                // Modo Aut√¥nomo
                React.createElement('div', {
                  className: "bg-blue-900 border border-blue-600 rounded-lg p-4"
                },
                  React.createElement('div', {
                    className: "flex items-center justify-between mb-3"
                  },
                    React.createElement('span', {
                      className: "text-sm font-bold text-blue-400"
                    }, 'ü§ñ Bot Aut√¥nomo'),
                    React.createElement('button', {
                      onClick: () => setIsAutonomousMode(!isAutonomousMode),
                      className: 'px-3 py-1 text-xs rounded font-bold transition-colors ' + (
                        isAutonomousMode ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'
                      )
                    }, isAutonomousMode ? 'ATIVO' : 'INATIVO')
                  ),
                  
                  isAutonomousMode ? 
                    React.createElement('div', {
                      className: "space-y-3"
                    },
                      React.createElement('div', null,
                        React.createElement('label', {
                          className: "block text-xs text-blue-300 mb-1"
                        }, 'üí∞ Meta de Lucro (USD)'),
                        React.createElement('input', {
                          type: 'number',
                          value: maxProfit,
                          onChange: (event) => setMaxProfit(event.target.value),
                          placeholder: '100',
                          className: 'w-full bg-gray-800 border border-gray-600 rounded px-2 py-1 text-white text-sm placeholder-gray-400'
                        })
                      ),
                      React.createElement('div', null,
                        React.createElement('label', {
                          className: "block text-xs text-blue-300 mb-1"
                        }, 'üõë Limite de Perda (USD)'),
                        React.createElement('input', {
                          type: 'number',
                          value: maxLoss,
                          onChange: (event) => setMaxLoss(event.target.value),
                          placeholder: '50',
                          className: 'w-full bg-gray-800 border border-gray-600 rounded px-2 py-1 text-white text-sm placeholder-gray-400'
                        })
                      ),
                      React.createElement('div', {
                        className: "text-xs text-blue-300"
                      },
                        'O bot analisar√° TODAS as moedas com 30 pontos de dados cada para m√°xima precis√£o e escolher√° a melhor oportunidade baseado em IA avan√ßada.'
                      )
                    ) : null
                ),

                // Estrat√©gia
                React.createElement('div', null,
                  React.createElement('label', {
                    className: "block text-sm font-bold text-white mb-2"
                  }, '‚ö° Estrat√©gia'),
                  React.createElement('select', {
                    value: strategy,
                    onChange: (event) => setStrategy(event.target.value),
                    className: 'w-full bg-gray-700 border border-gray-500 rounded-lg px-3 py-2 text-white font-medium focus:border-green-400 focus:ring-2 focus:ring-green-400'
                  },
                    React.createElement('option', { value: 'Conservador' }, 'Conservador'),
                    React.createElement('option', { value: 'Moderado' }, 'Moderado'),
                    React.createElement('option', { value: 'Agressivo' }, 'Agressivo')
                  )
                ),

                // Controles manuais (ocultos no modo aut√¥nomo)
                !isAutonomousMode ? 
                  React.createElement('div', {
                    className: "space-y-4"
                  },
                    // Tipo de contrato
                    React.createElement('div', null,
                      React.createElement('label', {
                        className: "block text-sm font-bold text-white mb-2"
                      }, 'üìà Tipo de Contrato'),
                      React.createElement('select', {
                        value: contractType,
                        onChange: (event) => setContractType(event.target.value),
                        className: 'w-full bg-gray-700 border border-gray-500 rounded-lg px-3 py-2 text-white font-medium focus:border-green-400 focus:ring-2 focus:ring-green-400'
                      },
                        React.createElement('option', { value: 'CALL' }, 'CALL (Rise)'),
                        React.createElement('option', { value: 'PUT' }, 'PUT (Fall)')
                      )
                    ),

                    // Valor
                    React.createElement('div', null,
                      React.createElement('label', {
                        className: "block text-sm font-bold text-white mb-2"
                      }, 'üí∞ Valor da Aposta (USD)'),
                      React.createElement('input', {
                        type: 'number',
                        value: entryValue,
                        onChange: (event) => setEntryValue(event.target.value),
                        placeholder: '10.00',
                        min: '0.35',
                        max: (balance || 1000).toString(),
                        step: '0.01',
                        className: 'w-full bg-gray-700 border border-gray-500 rounded-lg px-3 py-2 text-white font-medium placeholder-gray-400 focus:border-green-400 focus:ring-2 focus:ring-green-400'
                      })
                    ),

                    // Dura√ß√£o
                    React.createElement('div', null,
                      React.createElement('label', {
                        className: "block text-sm font-bold text-white mb-2"
                      }, '‚è±Ô∏è Dura√ß√£o (ticks)'),
                      React.createElement('select', {
                        value: duration,
                        onChange: (event) => setDuration(event.target.value),
                        className: 'w-full bg-gray-700 border border-gray-500 rounded-lg px-3 py-2 text-white font-medium focus:border-green-400 focus:ring-2 focus:ring-green-400'
                      },
                        React.createElement('option', { value: '5' }, '5 ticks'),
                        React.createElement('option', { value: '10' }, '10 ticks'),
                        React.createElement('option', { value: '15' }, '15 ticks'),
                        React.createElement('option', { value: '20' }, '20 ticks')
                      )
                    )
                  ) : 
                  React.createElement('div', {
                    className: "bg-green-900 border border-green-600 rounded-lg p-4"
                  },
                    React.createElement('div', {
                      className: "text-center"
                    },
                      React.createElement('div', {
                        className: "text-2xl mb-2"
                      }, 'ü§ñ'),
                      React.createElement('div', {
                        className: "text-sm font-bold text-green-400 mb-1"
                      }, 'MODO AUT√îNOMO ATIVO'),
                      React.createElement('div', {
                        className: "text-xs text-green-300"
                      }, 'O bot analisar√° TODAS as moedas e escolher√°:'),
                      React.createElement('div', {
                        className: "text-xs text-green-300 mt-1"
                      }, '‚Ä¢ Melhor moeda baseada em IA'),
                      React.createElement('div', {
                        className: "text-xs text-green-300"
                      }, '‚Ä¢ Tipo de contrato (CALL/PUT)'),
                      React.createElement('div', {
                        className: "text-xs text-green-300"
                      }, '‚Ä¢ Dura√ß√£o: 15min para Forex, 5min para outros'),
                      React.createElement('div', {
                        className: "text-xs text-green-300"
                      }, '‚Ä¢ Ranking completo de todas as moedas')
                    )
                  ),

                // Bot√µes
                React.createElement('button', {
                  onClick: () => {
                    try {
                      if (!isConnected) {
                        showError('N√£o conectado √† API do Deriv');
                        return;
                      }
                      const amount = parseFloat(entryValue);
                      if (!entryValue || isNaN(amount) || amount <= 0) {
                        showError('Valor de entrada inv√°lido');
                        return;
                      }
                      if (amount < 0.35) {
                        showError('Valor m√≠nimo de entrada: $0.35');
                        return;
                      }
                      if (amount > (balance || 0)) {
                        showError('Saldo insuficiente. Saldo: $' + safeFormatNumber(balance || 0, 2));
                        return;
                      }
                      clearError();
                      alert('‚úÖ Par√¢metros v√°lidos! Pronto para trading.');
                    } catch (error) {
                      showError('Erro ao validar par√¢metros: ' + error.message);
                    }
                  },
                  disabled: !isConnected,
                  className: 'w-full py-3 text-sm bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg font-bold transition-colors'
                }, 'TESTAR PAR√ÇMETROS'),

                React.createElement('button', {
                  onClick: executeTrade,
                  disabled: !isConnected || !entryValue || parseFloat(entryValue) > (balance || 0) || isExecutingTrade,
                  className: 'w-full py-3 text-sm bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg font-bold transition-colors'
                }, isExecutingTrade ? 'EXECUTANDO...' : 'EXECUTAR TRADE MANUAL'),

                React.createElement('button', {
                  onClick: () => {
                    try {
                      if (!isConnected) {
                        showError('Conecte-se primeiro √† API do Deriv');
                        return;
                      }
                      
                      if (isAutonomousMode) {
                        // No modo aut√¥nomo, ativar/desativar trading autom√°tico
                        setIsTrading(!isTrading);
                        if (!isTrading) {
                          console.log('ü§ñ Iniciando trading aut√¥nomo com IA...');
                        } else {
                          console.log('üõë Parando trading aut√¥nomo...');
                        }
                      } else {
                        // Modo manual tradicional
                        setIsTrading(!isTrading);
                      }
                      clearError();
                    } catch (error) {
                      showError('Erro ao alterar modo de trading: ' + error.message);
                    }
                  },
                  disabled: !isConnected || (isAutonomousMode && !entryValue),
                  className: 'w-full py-4 rounded-lg font-bold text-base flex items-center justify-center space-x-2 disabled:bg-gray-600 disabled:cursor-not-allowed transition-colors ' + (
                    isTrading ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
                  )
                },
                  React.createElement('span', null, isAutonomousMode ? 'ü§ñ' : '‚ñ∂Ô∏è'),
                  React.createElement('span', {
                    className: "truncate"
                  }, isTrading ? 
                    (isAutonomousMode ? 'PARAR BOT IA' : 'PARAR AUTO') : 
                    (isAutonomousMode ? 'INICIAR BOT IA' : 'INICIAR AUTO')
                  )
                ),

                isConnected ? 
                  React.createElement('button', {
                    onClick: disconnect,
                    className: 'w-full py-3 border border-red-600 text-red-400 hover:bg-red-900 rounded-lg transition-colors font-medium'
                  }, 'DESCONECTAR') : null,

                React.createElement('div', {
                  className: "bg-gray-800 rounded-lg p-4 text-center"
                },
                  React.createElement('div', {
                    className: "text-sm text-gray-400 mb-1"
                  }, 'Lucro/Preju√≠zo Total'),
                  React.createElement('div', {
                    className: 'text-2xl font-bold ' + ((profit || 0) >= 0 ? 'text-green-400' : 'text-red-400')
                  }, '$' + safeFormatNumber(profit || 0, 2))
                ),

                React.createElement('div', {
                  className: "bg-gray-800 rounded-lg p-4"
                },
                  React.createElement('div', {
                    className: "grid grid-cols-2 gap-4"
                  },
                    React.createElement('div', {
                      className: "text-center"
                    },
                      React.createElement('div', {
                        className: "text-xs text-gray-400 mb-1"
                      }, isAutonomousMode ? 'Bot IA Status' : 'Bot Status'),
                      React.createElement('div', {
                        className: 'text-sm font-bold ' + (isTrading ? 'text-green-400' : 'text-gray-400')
                      }, isTrading ? (isAutonomousMode ? 'IA ATIVO' : 'ATIVO') : 'PARADO')
                    ),
                    React.createElement('div', {
                      className: "text-center"
                    },
                      React.createElement('div', {
                        className: "text-xs text-gray-400 mb-1"
                      }, 'Contratos'),
                      React.createElement('div', {
                        className: "text-sm font-bold text-white"
                      }, trades.length)
                    )
                  ),
                  
                  isAutonomousMode ? 
                    React.createElement('div', {
                      className: "mt-3 pt-3 border-t border-gray-700"
                    },
                      React.createElement('div', {
                        className: "flex items-center justify-between mb-2"
                      },
                        React.createElement('span', {
                          className: "text-xs text-blue-400"
                        }, 'Moeda Ativa:'),
                        React.createElement('span', {
                          className: "text-xs font-bold text-white"
                        }, symbol)
                      ),
                      marketAnalysis ? 
                        React.createElement('div', {
                          className: "space-y-1"
                        },
                          React.createElement('div', {
                            className: "flex items-center justify-between"
                          },
                            React.createElement('span', {
                              className: "text-xs text-blue-400"
                            }, '√öltima An√°lise:'),
                            React.createElement('span', {
                              className: "text-xs text-blue-300"
                            }, marketAnalysis.timestamp)
                          ),
                          React.createElement('div', {
                            className: "flex items-center justify-between"
                          },
                            React.createElement('span', {
                              className: "text-xs text-gray-400"
                            }, 'Confian√ßa IA:'),
                            React.createElement('span', {
                              className: "text-xs font-bold text-white"
                            }, safeFormatNumber((marketAnalysis.confidence || 0) * 100, 1) + '%')
                          )
                        ) :
                        React.createElement('div', {
                          className: "text-center"
                        },
                          React.createElement('div', {
                            className: "text-xs text-blue-300"
                          }, 'Aguardando an√°lise...')
                        )
                    ) : null,
                  
                  React.createElement('div', {
                    className: "mt-3 pt-3 border-t border-gray-700"
                  },
                    React.createElement('div', {
                      className: "flex items-center justify-between"
                    },
                      React.createElement('span', {
                        className: "text-sm text-gray-400"
                      }, 'Saldo Atual:'),
                      React.createElement('span', {
                        className: "text-sm font-bold text-white"
                      }, '$' + safeFormatNumber(balance || 0, 2))
                    )
                  )
                )
              )
            )
          );
        }

        // Tratamento global de erros
        window.addEventListener('error', function(event) {
          console.error('Erro global capturado:', event.error);
          event.preventDefault();
        });

        window.addEventListener('unhandledrejection', function(event) {
          console.error('Promise rejeitada n√£o tratada:', event.reason);
          event.preventDefault();
        });

        ReactDOM.render(React.createElement(DerivTradingPlatform), document.getElementById('root'));
    </script>
</body>
</html>